<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Content Extractor for LLM Processing</title>
    <link rel="icon" type="image/svg+xml" href="static/favicon.svg">
    <link rel="icon" type="image/png" href="static/favicon.png">
    <style>
:root {
    color-scheme: dark;
    --sidebar-bg: #202123;
    --sidebar-border: #2d2f34;
    --chat-bg: #343541;
    --chat-surface: #444654;
    --chat-surface-user: #2b2c34;
    --bubble-border: rgba(255, 255, 255, 0.04);
    --accent: #10a37f;
    --accent-hover: #1a7f64;
    --text-primary: #ececf1;
    --text-muted: #8e909c;
    --radius-lg: 18px;
    --radius-sm: 10px;
    --panel-bg: #40414f;
    --panel-border: #565869;
    --surface-secondary: rgba(64, 65, 79, 0.85);
    --shadow-strong: rgba(0, 0, 0, 0.25);
    --status-default-bg: rgba(64, 65, 79, 0.82);
    --status-default-border: rgba(255, 255, 255, 0.08);
    --status-default-color: var(--text-primary);
    --status-info-bg: rgba(59, 130, 246, 0.2);
    --status-info-border: rgba(59, 130, 246, 0.35);
    --status-info-color: #93c5fd;
    --status-success-bg: rgba(16, 163, 127, 0.2);
    --status-success-border: rgba(16, 163, 127, 0.35);
    --status-success-color: #6ee7b7;
    --status-warning-bg: rgba(234, 179, 8, 0.18);
    --status-warning-border: rgba(234, 179, 8, 0.32);
    --status-warning-color: #facc15;
    --status-error-bg: rgba(239, 68, 68, 0.2);
    --status-error-border: rgba(239, 68, 68, 0.35);
    --status-error-color: #fca5a5;
    --button-disabled-bg: #3f4147;
}

:root[data-theme="light"] {
    color-scheme: light;
    --sidebar-bg: #f5f6fb;
    --sidebar-border: #dfe3f1;
    --chat-bg: #f7f8fc;
    --chat-surface: #ffffff;
    --chat-surface-user: #eef4ff;
    --bubble-border: rgba(15, 23, 42, 0.08);
    --accent: #0b8a6f;
    --accent-hover: #0a725c;
    --text-primary: #1f2933;
    --text-muted: #6b7280;
    --panel-bg: #ffffff;
    --panel-border: #dfe3f1;
    --surface-secondary: rgba(255, 255, 255, 0.95);
    --shadow-strong: rgba(15, 23, 42, 0.1);
    --status-default-bg: rgba(15, 23, 42, 0.05);
    --status-default-border: rgba(15, 23, 42, 0.12);
    --status-default-color: #1f2933;
    --status-info-bg: rgba(59, 130, 246, 0.1);
    --status-info-border: rgba(59, 130, 246, 0.2);
    --status-info-color: #2563eb;
    --status-success-bg: rgba(16, 163, 127, 0.12);
    --status-success-border: rgba(16, 163, 127, 0.25);
    --status-success-color: #047857;
    --status-warning-bg: rgba(234, 179, 8, 0.12);
    --status-warning-border: rgba(234, 179, 8, 0.25);
    --status-warning-color: #b45309;
    --status-error-bg: rgba(239, 68, 68, 0.12);
    --status-error-border: rgba(239, 68, 68, 0.25);
    --status-error-color: #b91c1c;
    --button-disabled-bg: #d1d5db;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Inter', 'Segoe UI', sans-serif;
    background: var(--chat-bg);
    color: var(--text-primary);
    height: 100vh;
    display: flex;
}

button {
    font: inherit;
}

.app-shell {
    display: flex;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

.app-sidebar {
    width: 260px;
    background: var(--sidebar-bg);
    border-right: 1px solid var(--sidebar-border);
    display: flex;
    flex-direction: column;
    padding: 24px 20px;
    gap: 24px;
    color: var(--text-primary);
}

.sidebar-header {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.sidebar-title {
    font-size: 1rem;
    font-weight: 600;
}

.sidebar-new {
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
    padding: 10px 14px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: background 0.2s ease;
    text-align: left;
}

.sidebar-new:hover {
    background: rgba(255, 255, 255, 0.16);
}

:root[data-theme="light"] .sidebar-new {
    background: rgba(15, 23, 42, 0.05);
    border-color: rgba(15, 23, 42, 0.08);
}

:root[data-theme="light"] .sidebar-new:hover {
    background: rgba(15, 23, 42, 0.12);
}

.sidebar-nav {
    display: flex;
    flex-direction: column;
    gap: 12px;
    color: var(--text-muted);
    font-size: 0.9rem;
}

.sidebar-list {
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.sidebar-list li {
    padding: 0;
    border-radius: var(--radius-sm);
    background: rgba(255, 255, 255, 0.03);
    display: flex;
    align-items: center;
    gap: 6px;
    transition: background 0.2s ease, border 0.2s ease;
}

.sidebar-list li.active {
    background: rgba(16, 163, 127, 0.25);
    border: 1px solid rgba(16, 163, 127, 0.4);
}

.sidebar-chat-item {
    flex: 1;
    border: none;
    background: transparent;
    color: inherit;
    text-align: left;
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    cursor: pointer;
}

.sidebar-chat-title {
    font-weight: 600;
    font-size: 0.95rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-chat-meta {
    font-size: 0.75rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.sidebar-list li.active .sidebar-chat-title {
    color: #ffffff;
}

.sidebar-list li.active .sidebar-chat-meta {
    color: rgba(255, 255, 255, 0.75);
}

.sidebar-chat-delete {
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0 10px;
    font-size: 0.9rem;
    line-height: 1;
    opacity: 0;
    transition: opacity 0.2s ease, color 0.2s ease;
}

.sidebar-chat-delete:hover {
    opacity: 1;
    color: var(--text-primary);
}

.sidebar-list li:hover .sidebar-chat-delete,
.sidebar-list li.active .sidebar-chat-delete {
    opacity: 1;
}

.sidebar-list li.empty {
    padding: 10px 12px;
    color: var(--text-muted);
}

.sidebar-clear {
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: transparent;
    color: var(--text-muted);
    padding: 8px 12px;
    border-radius: var(--radius-sm);
    font-size: 0.85rem;
    cursor: pointer;
    margin-bottom: 6px;
    transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
}

.sidebar-clear:hover {
    background: rgba(255, 255, 255, 0.08);
    color: var(--text-primary);
}

.option-description {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 6px;
    line-height: 1.4;
}

.playwright-mode-toggle {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    margin-top: 8px;
}

.playwright-mode-toggle label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.9rem;
    cursor: pointer;
}

#playwrightServer:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

:root[data-theme="light"] .sidebar-list li {
    background: rgba(15, 23, 42, 0.05);
}

:root[data-theme="light"] .sidebar-list li.active {
    background: rgba(16, 163, 127, 0.35);
    border-color: rgba(16, 163, 127, 0.45);
}

:root[data-theme="light"] .sidebar-list li.active .sidebar-chat-title {
    color: #0b392e;
}

:root[data-theme="light"] .sidebar-list li.active .sidebar-chat-meta {
    color: rgba(11, 57, 46, 0.7);
}

:root[data-theme="light"] .sidebar-chat-delete:hover {
    color: var(--text-primary);
}

:root[data-theme="light"] .sidebar-clear {
    border-color: rgba(15, 23, 42, 0.12);
    color: var(--text-muted);
}

:root[data-theme="light"] .sidebar-clear:hover {
    background: rgba(15, 23, 42, 0.1);
    color: var(--text-primary);
}

.app-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--chat-bg);
}

.chat-header {
    padding: 24px 32px;
    border-bottom: 1px solid var(--sidebar-border);
}

.chat-header-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
}

.chat-header-title {
    display: flex;
    align-items: center;
    gap: 16px;
}

.brand-mark {
    font-size: 28px;
}

.theme-toggle {
    width: 42px;
    height: 42px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.16);
    background: rgba(255, 255, 255, 0.08);
    color: var(--text-primary);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    transition: background 0.2s ease, transform 0.2s ease;
}

.theme-toggle:hover {
    background: rgba(255, 255, 255, 0.18);
    transform: translateY(-1px);
}

:root[data-theme="light"] .theme-toggle {
    border-color: rgba(15, 23, 42, 0.12);
    background: rgba(15, 23, 42, 0.08);
}

:root[data-theme="light"] .theme-toggle:hover {
    background: rgba(15, 23, 42, 0.16);
}

.chat-header-title h1 {
    font-size: 1.6rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.chat-header-title p {
    color: var(--text-muted);
    font-size: 0.95rem;
}

.system-messages {
    padding: 16px 32px 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.system-messages > div {
    display: none;
    padding: 12px 16px;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
}

.error-message {
    background: rgba(239, 68, 68, 0.12);
    border-color: rgba(239, 68, 68, 0.35);
    color: #fca5a5;
}

.warning-message {
    background: rgba(234, 179, 8, 0.12);
    border-color: rgba(234, 179, 8, 0.35);
    color: #facc15;
}

.success-message {
    background: rgba(16, 163, 127, 0.12);
    border-color: rgba(16, 163, 127, 0.35);
    color: #6ee7b7;
}

.extraction-method {
    background: rgba(79, 70, 229, 0.12);
    border-color: rgba(79, 70, 229, 0.35);
    color: #a5b4fc;
}

.chat-scroll {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 24px;
    padding: 24px 32px;
}

.conversation {
    display: flex;
    flex-direction: column;
    gap: 24px;
}

.conversation-message {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    width: 100%;
}

.conversation-message.assistant:not(.status) {
    display: grid;
    grid-template-columns: 34px minmax(0, 1fr);
    column-gap: 16px;
}

.conversation-message.assistant:not(.status) .conversation-avatar {
    grid-row: 1 / span 2;
}

.conversation-message.assistant {
    justify-content: flex-start;
}

.conversation-message.user {
    justify-content: flex-end;
}

.conversation-avatar {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.08);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    color: var(--text-primary);
    flex-shrink: 0;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.08);
    margin-top: 4px;
}

.conversation-message.user .conversation-avatar {
    background: rgba(16, 163, 127, 0.25);
    display: none;
}

.conversation-message.assistant .conversation-avatar {
    background: rgba(59, 130, 246, 0.25);
}

:root[data-theme="light"] .conversation-avatar {
    background: rgba(59, 130, 246, 0.12);
    box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.1);
}

:root[data-theme="light"] .conversation-message.user .conversation-avatar {
    background: rgba(16, 163, 127, 0.18);
}

.conversation-message.status {
    flex-direction: column;
    gap: 12px;
    align-items: flex-start;
}

.conversation-message.status .conversation-avatar {
    display: none;
}

.conversation-bubble {
    max-width: min(680px, 100%);
    border-radius: var(--radius-lg);
    padding: 16px 20px;
    background: var(--chat-surface);
    border: 1px solid var(--bubble-border);
    line-height: 1.58;
    font-size: 0.98rem;
    color: var(--text-primary);
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 12px;
    box-shadow: 0 12px 24px var(--shadow-strong);
    flex: 0 1 auto;
    min-width: 0;
}

.conversation-message.assistant:not(.status) .conversation-bubble {
    width: min(680px, 100%);
    max-width: min(680px, 100%);
}

.conversation-message.user .conversation-bubble {
    background: var(--chat-surface-user);
    margin-left: auto;
}

.conversation-message.status .conversation-bubble {
    background: var(--status-default-bg);
    border-color: var(--status-default-border);
    color: var(--status-default-color);
    max-width: 520px;
    text-align: left;
    margin-left: calc(34px + 16px);
    margin-right: auto;
}

.conversation-message.status.status-info .conversation-bubble {
    background: var(--status-info-bg);
    border-color: var(--status-info-border);
    color: var(--status-info-color);
}

.conversation-message.status.status-success .conversation-bubble {
    background: var(--status-success-bg);
    border-color: var(--status-success-border);
    color: var(--status-success-color);
}

.conversation-message.status.status-warning .conversation-bubble {
    background: var(--status-warning-bg);
    border-color: var(--status-warning-border);
    color: var(--status-warning-color);
}

.conversation-message.status.status-error .conversation-bubble {
    background: var(--status-error-bg);
    border-color: var(--status-error-border);
    color: var(--status-error-color);
}

.bubble-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    color: var(--text-muted);
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.04em;
}

.bubble-label {
    font-weight: 600;
    color: var(--text-primary);
}

.bubble-actions {
    display: flex;
    align-items: center;
    gap: 6px;
}

.bubble-copy {
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.08);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 0.74rem;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.bubble-copy:hover {
    background: rgba(255, 255, 255, 0.18);
}

:root[data-theme="light"] .bubble-copy {
    border-color: rgba(15, 23, 42, 0.12);
    background: rgba(15, 23, 42, 0.08);
}

:root[data-theme="light"] .bubble-copy:hover {
    background: rgba(15, 23, 42, 0.16);
}

.conversation-bubble .bubble-text {
    white-space: pre-wrap;
}

.assistant-loading-inline {
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.assistant-loading-inline .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent);
    animation: pulse 1.5s infinite ease-in-out;
}

.assistant-extraction {
    margin-top: 12px;
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-sm);
    background: var(--surface-secondary);
    padding: 14px 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 100%;
}

.assistant-extraction-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}

.assistant-extraction-meta {
    font-size: 0.8rem;
    color: var(--text-muted);
    background: rgba(255, 255, 255, 0.08);
    padding: 4px 10px;
    border-radius: 999px;
}

:root[data-theme="light"] .assistant-extraction-meta {
    background: rgba(15, 23, 42, 0.08);
}

.assistant-extraction-toggle {
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    padding: 8px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    cursor: pointer;
}

.assistant-extraction-toggle:hover {
    background: rgba(255, 255, 255, 0.08);
}

:root[data-theme="light"] .assistant-extraction-toggle:hover {
    background: rgba(15, 23, 42, 0.08);
}

.assistant-extraction-icon {
    font-size: 0.9rem;
}

.assistant-extraction-body {
    border-top: 1px solid var(--panel-border);
    padding-top: 12px;
    display: none;
}

.assistant-extraction.open .assistant-extraction-body {
    display: block;
}

.assistant-llm {
    white-space: normal;
}

.assistant-llm-reason {
    font-size: 0.9rem;
    color: var(--text-muted);
    background: rgba(255, 255, 255, 0.04);
    border-radius: var(--radius-sm);
    padding: 10px 12px;
}

.assistant-search-list {
    margin-top: 12px;
    margin-bottom: 0;
    padding-left: 20px;
    color: var(--text-primary);
}

.assistant-search-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 14px;
}

.assistant-search-button {
    padding: 8px 14px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--panel-border);
    background: var(--panel-bg);
    color: var(--text-primary);
    cursor: pointer;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    transition: background 0.2s ease, border-color 0.2s ease;
}

.assistant-search-button:hover {
    background: rgba(255, 255, 255, 0.08);
}

.assistant-search-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

:root[data-theme="light"] .assistant-llm-reason {
    background: rgba(15, 23, 42, 0.06);
}

.assistant-tool-decision {
    font-size: 0.9rem;
    color: var(--text-primary);
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.assistant-tool-decision-title {
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
}

.assistant-tool-decision-args {
    margin: 0;
    padding-left: 18px;
    color: var(--text-muted);
}

.assistant-tool-decision-args li {
    margin-bottom: 4px;
}

.assistant-tool-decision-status {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-muted);
}

.assistant-tool-decision-status.success {
    color: var(--status-success-color);
}

.assistant-tool-decision-status.error {
    color: var(--status-error-color);
}

:root[data-theme="light"] .assistant-tool-decision-status.success {
    color: var(--accent);
}

:root[data-theme="light"] .assistant-tool-decision-status.error {
    color: var(--status-error-color);
}

.assistant-tool-decision-details {
    font-size: 0.85rem;
    color: var(--text-muted);
}

:root[data-theme="light"] .assistant-search-button {
    background: rgba(15, 23, 42, 0.05);
}

:root[data-theme="light"] .assistant-search-button:hover {
    background: rgba(15, 23, 42, 0.12);
}

.assistant-tool-usage {
    margin-top: 16px;
    padding: 12px 14px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--panel-border);
    background: rgba(255, 255, 255, 0.04);
    font-size: 0.9rem;
}

.assistant-tool-label {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
}

.assistant-tool-usage ul {
    margin: 0;
    padding-left: 20px;
    color: var(--text-primary);
}

.assistant-tool-name {
    font-weight: 600;
}

.assistant-tool-meta {
    font-size: 0.75rem;
    color: var(--text-muted);
}

.assistant-search-note {
    margin-top: 8px;
    font-size: 0.85rem;
    color: var(--text-muted);
}

.assistant-tool-usage li.assistant-tool-error {
    color: var(--status-error-color);
}

:root[data-theme="light"] .assistant-tool-usage {
    background: rgba(15, 23, 42, 0.05);
}

.chat-input-panel {
    position: sticky;
    bottom: 0;
    padding: 20px 32px 32px;
    background: linear-gradient(180deg, rgba(52, 53, 65, 0) 0%, rgba(52, 53, 65, 0.85) 40%, rgba(52, 53, 65, 1) 100%);
    border-top: 1px solid var(--sidebar-border);
    display: flex;
    flex-direction: column;
    gap: 16px;
}

:root[data-theme="light"] .chat-input-panel {
    background: linear-gradient(180deg, rgba(247, 248, 252, 0) 0%, rgba(247, 248, 252, 0.85) 40%, rgba(247, 248, 252, 1) 100%);
}

.chat-input-inner {
    display: flex;
    gap: 12px;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-lg);
    padding: 12px 16px;
}

.task-input {
    flex: 1;
    background: transparent;
    color: var(--text-primary);
    border: none;
    resize: none;
    min-height: 68px;
    max-height: 200px;
    overflow-y: auto;
}

.task-input::placeholder {
    color: var(--text-muted);
}

.task-input:focus {
    outline: none;
}

.chat-input-actions {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

.process-button {
    padding: 10px 18px;
    background: var(--accent);
    border: none;
    border-radius: var(--radius-sm);
    color: #fff;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease;
    min-width: 120px;
}

.process-button:hover {
    background: var(--accent-hover);
}

.process-button:disabled {
    background: var(--button-disabled-bg);
    cursor: not-allowed;
}

.toggle-panel {
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
}

.toggle-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    cursor: pointer;
    color: var(--text-primary);
}

.toggle-section {
    padding: 18px 20px;
    border-top: 1px solid var(--panel-border);
    display: flex;
    flex-direction: column;
    gap: 18px;
}

.toggle-section.collapsed {
    display: none;
}

.toggle-icon {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.08);
}

:root[data-theme="light"] .toggle-icon {
    background: rgba(15, 23, 42, 0.08);
}

.toggle-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 18px;
}

.toggle-grid + .toggle-grid {
    margin-top: 4px;
}

.option-group {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 12px;
    color: var(--text-primary);
    font-size: 0.95rem;
    width: 100%;
}

.option-group .option-label {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: var(--text-muted);
}

.option-group input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--accent);
}

.option-group input[type="number"],
.option-group input[type="url"],
.llm-select {
    width: 100%;
    padding: 10px 12px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--panel-border);
    background: var(--chat-surface);
    color: var(--text-primary);
}

.option-group.option-group-wide {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    width: 100%;
}

.toggle-grid .option-group.option-group-wide {
    grid-column: 1 / -1;
}

.llm-model-row {
    display: flex;
    gap: 8px;
    width: 100%;
}

.llm-refresh-button {
    padding: 10px 12px;
    border-radius: var(--radius-sm);
    transition: background 0.2s ease, border-color 0.2s ease;
    border: 1px solid var(--panel-border);
    background: var(--chat-surface);
    color: var(--text-primary);
    cursor: pointer;
}

.llm-refresh-button:hover {
    background: rgba(255, 255, 255, 0.08);
}

:root[data-theme="light"] .llm-refresh-button {
    background: rgba(15, 23, 42, 0.04);
}

:root[data-theme="light"] .llm-refresh-button:hover {
    background: rgba(15, 23, 42, 0.12);
}

.llm-format-toggle {
    display: flex;
    flex-wrap: wrap;
    gap: 14px;
}

.llm-format-toggle label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
    font-weight: 500;
}

.llm-format-toggle input[type="radio"] {
    accent-color: var(--accent);
}

.llm-format-description {
    font-size: 0.85rem;
    color: var(--text-muted);
}

.progress-section {
    display: none;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-lg);
    padding: 16px 18px;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background: #2d2f34;
    border-radius: 999px;
    overflow: hidden;
    margin-bottom: 12px;
}

:root[data-theme="light"] .progress-bar {
    background: rgba(15, 23, 42, 0.08);
}

.progress-fill {
    height: 100%;
    background: var(--accent);
    width: 0%;
    transition: width 0.3s ease;
}

.status-text {
    font-size: 0.85rem;
    text-align: center;
    color: var(--text-muted);
}

.llm-progress {
    display: none;
    margin-top: 12px;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius-sm);
    padding: 12px 14px;
}

.llm-progress .progress-bar {
    height: 4px;
    margin-bottom: 8px;
    background: rgba(255, 255, 255, 0.12);
}

:root[data-theme="light"] .llm-progress .progress-bar {
    background: rgba(15, 23, 42, 0.08);
}

.llm-progress .status-text {
    text-align: left;
}

.assistant-tabs {
    display: flex;
    gap: 12px;
    border-bottom: 1px solid var(--panel-border);
    padding-bottom: 8px;
}

.assistant-tab-button {
    padding: 8px 12px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    font-weight: 500;
}

.assistant-tab-button.active {
    color: var(--text-primary);
    border-bottom: 2px solid var(--accent);
}

.assistant-tab-content {
    display: none;
    margin-top: 12px;
}

.assistant-tab-content.active {
    display: block;
}

.assistant-content-preview {
    background: #202123;
    border: 1px solid #2d2f34;
    border-radius: var(--radius-sm);
    padding: 16px;
    max-height: 320px;
    overflow-y: auto;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
    font-size: 0.9rem;
    line-height: 1.5;
    color: var(--text-primary);
}

.assistant-preview-header,
.assistant-downloads {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 12px;
    align-items: center;
    justify-content: flex-end;
}

.assistant-download-button {
    padding: 8px 12px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--panel-border);
    background: var(--panel-bg);
    color: var(--text-primary);
    cursor: pointer;
}

.assistant-download-button.copy-main {
    background: var(--accent);
    border-color: var(--accent);
}

.assistant-download-button.copy-main:hover {
    background: var(--accent-hover);
}

.assistant-download-button.secondary,
.assistant-download-button.tertiary {
    background: var(--panel-bg);
    border-color: var(--panel-border);
}

.assistant-download-button.secondary:hover,
.assistant-download-button.tertiary:hover {
    background: rgba(255, 255, 255, 0.08);
}

:root[data-theme="light"] .assistant-download-button.secondary:hover,
:root[data-theme="light"] .assistant-download-button.tertiary:hover {
    background: rgba(15, 23, 42, 0.08);
}

@media (max-width: 1024px) {
    .app-sidebar {
        display: none;
    }

    .chat-header {
        padding: 20px 24px;
    }

    .chat-scroll,
    .chat-input-panel,
    .system-messages {
        padding-left: 20px;
        padding-right: 20px;
    }
}

@media (max-width: 768px) {
    .chat-scroll {
        padding: 16px 18px;
    }

    .conversation-bubble {
        padding: 14px 16px;
    }

    .chat-input-panel {
        padding: 16px 18px 24px;
    }

    .chat-input-inner {
        flex-direction: column;
        align-items: stretch;
    }

    .toggle-section {
        padding: 16px 18px;
    }

    .toggle-grid {
        grid-template-columns: 1fr;
    }

    .toggle-grid .option-group.option-group-wide {
        grid-column: 1;
    }

    .chat-input-actions {
        align-items: flex-end;
    }

    .theme-toggle {
        width: 38px;
        height: 38px;
    }

    .assistant-search-actions {
        flex-direction: column;
        align-items: stretch;
    }

    .assistant-search-button {
        justify-content: center;
    }
}
    </style>
</head>
<body>
    <div class="app-shell">
        <aside class="app-sidebar">
            <div class="sidebar-header">
                <span class="sidebar-title">Web Content Extractor</span>
                <button type="button" class="sidebar-new" onclick="startNewChat()">+ New Chat</button>
            </div>
            <div class="sidebar-nav">
                <button type="button" class="sidebar-clear" onclick="clearChatHistory()">Clear History</button>
                <h3>Recent</h3>
                <ul class="sidebar-list" id="chatHistoryList"></ul>
            </div>
        </aside>
        <main class="app-main">
            <header class="chat-header">
                <div class="chat-header-bar">
                    <div class="chat-header-title">
                        <span class="brand-mark">🌐</span>
                        <div>
                            <h1>Web Content Extractor</h1>
                            <p>Paste an instruction with a URL. The app fetches the page and pushes it through your Ollama model automatically.</p>
                        </div>
                    </div>
                    <button type="button" class="theme-toggle" id="themeToggle" aria-label="Switch to light theme">☀️</button>
                </div>
            </header>
            <section class="system-messages">
                <div class="error-message" id="errorMessage"></div>
                <div class="warning-message" id="warningMessage"></div>
                <div class="success-message" id="successMessage"></div>
                <div class="extraction-method" id="extractionMethod"></div>
                <div class="llm-progress" id="llmProgress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="llmProgressFill"></div>
                    </div>
                    <div class="status-text" id="llmStatusText"></div>
                </div>
            </section>
            <section class="chat-scroll">
                <div class="conversation" id="chatMessages"></div>
                <div class="progress-section" id="progressSection">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="status-text" id="statusText">Initializing...</div>
                </div>
            </section>
            <footer class="chat-input-panel">
                <div class="chat-input-inner">
                    <textarea
                        class="task-input"
                        id="taskInput"
                        placeholder="Send a message or paste an instruction with a URL..."></textarea>
                    <div class="chat-input-actions">
                        <button class="process-button" id="processButton" onclick="runTask()">
                            Run Task
                        </button>
                    </div>
                </div>
                <div class="toggle-panel collapsed" id="optionsPanel">
                    <div class="toggle-title collapsed" id="optionsToggle">
                        <span>Extraction &amp; Server Options</span>
                        <span class="toggle-icon" id="optionsToggleIcon">▸</span>
                    </div>
                    <div class="toggle-section collapsed" id="optionsToggleContent">
                        <div class="toggle-grid">
                            <label class="option-group">
                                <input type="checkbox" id="includeImages" checked>
                                <span>Include Image Alt Text</span>
                            </label>
                            <label class="option-group">
                                <input type="checkbox" id="includeLinks" checked>
                                <span>Include Link Text</span>
                            </label>
                            <label class="option-group">
                                <input type="checkbox" id="includeMetadata" checked>
                                <span>Include Page Metadata</span>
                            </label>
                            <label class="option-group">
                                <input type="checkbox" id="expandDynamic" checked>
                                <span>Expand Dynamic Content</span>
                            </label>
                            <label class="option-group">
                                <input type="checkbox" id="cleanContent" checked>
                                <span>Clean &amp; Format Content</span>
                            </label>
                            <label class="option-group">
                                <input type="checkbox" id="blockMedia">
                                <span>Block CSS &amp; heavy media requests</span>
                            </label>
                        </div>
                        <div class="toggle-grid">
                            <label class="option-group option-group-wide">
                                <span>Playwright Server URL</span>
                                <input type="url" id="playwrightServer" value="http://localhost:3050" placeholder="http://localhost:3050">
                            </label>
                            <label class="option-group option-group-wide">
                                <span class="option-label">Playwright Helper Mode</span>
                                <div class="playwright-mode-toggle" role="radiogroup" aria-label="Playwright helper mode">
                                    <label>
                                        <input type="radio" name="playwrightMode" value="embedded" checked>
                                        Embedded (near-instant)
                                    </label>
                                    <label>
                                        <input type="radio" name="playwrightMode" value="container">
                                        Containerised helper
                                    </label>
                                </div>
                                <p class="option-description">Embedded mode keeps a warm Chromium instance inside this app for fastest results. Container mode targets an external helper (Docker or remote host).</p>
                            </label>
                            <label class="option-group">
                                <span>Wait Time (ms)</span>
                                <input type="number" id="waitTime" value="3000" min="1000" max="10000" step="500">
                            </label>
                            <label class="option-group option-group-wide">
                                <span>Ollama Server URL</span>
                                <input type="url" id="ollamaServer" class="llm-input" placeholder="http://localhost:11434">
                            </label>
                            <label class="option-group option-group-wide">
                                <span>Ollama Model</span>
                                <div class="llm-model-row">
                                    <select id="ollamaModel" class="llm-select">
                                        <option value="" disabled selected>Loading models...</option>
                                    </select>
                                    <button class="llm-refresh-button" type="button" onclick="loadOllamaModels(true)">↻ Refresh</button>
                                </div>
                            </label>
                            <div class="option-group option-group-wide">
                                <span class="option-label" id="llmFormatLabel">LLM Payload Format</span>
                                <div class="llm-format-toggle" role="radiogroup" aria-labelledby="llmFormatLabel">
                                    <label>
                                        <input type="radio" name="llmPayloadFormat" value="markdown" checked>
                                        Markdown
                                    </label>
                                    <label>
                                        <input type="radio" name="llmPayloadFormat" value="json">
                                        JSON
                                    </label>
                                </div>
                                <p class="llm-format-description">Controls the structure of the payload sent to your Ollama model.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </footer>
        </main>
    </div>

<script>
let extractedData = null;
const extractionHistory = [];
const PLAYWRIGHT_STORAGE_KEY = 'playwrightServerUrl';
const OLLAMA_SERVER_STORAGE_KEY = 'ollamaServerUrl';
const OLLAMA_MODEL_STORAGE_KEY = 'ollamaModel';
const PREFERRED_OLLAMA_MODEL = 'gpt-oss:120b-cloud';
const DEFAULT_OLLAMA_MODELS = [
    PREFERRED_OLLAMA_MODEL,
    'llama3.1:latest',
    'llama3',
    'mistral',
    'mixtral',
    'phi3'
];
const THEME_STORAGE_KEY = 'uiTheme';
const LLM_RESPONSE_FORMAT_HINT = [
    'Format your entire response as semantic HTML that renders cleanly in a browser.',
    'Use headings (<h2>, <h3>), paragraphs, bullet lists, numbered lists, tables, and short sections where helpful.',
    'Wrap code samples in <pre><code>...</code></pre> blocks.',
    'Avoid including <script>, <iframe>, <object>, <embed>, <html>, <head>, or <body> tags.'
].join(' ');
const PLAYWRIGHT_MODE_STORAGE_KEY = 'playwrightHelperMode';
const PLAYWRIGHT_CACHE_LIMIT = 32;
const PLAYWRIGHT_CACHE_TTL_MS = 2 * 60 * 1000;
const PLAYWRIGHT_EMBEDDED_ENDPOINT = '/api/playwright/extract';
const CHAT_HISTORY_STORAGE_KEY = 'chatHistorySessions';
const ACTIVE_CHAT_STORAGE_KEY = 'activeChatSessionId';
const CHAT_HISTORY_LIMIT = 30;
const CHAT_DEFAULT_TITLE = 'New chat';
const PLAYWRIGHT_HOST_CANONICAL_MAP = {
    'youtu.be': 'youtube.com',
    'm.youtube.com': 'youtube.com',
    'music.youtube.com': 'youtube.com',
    'youtube-nocookie.com': 'youtube.com',
    'news.google.com': 'google.com',
    'maps.google.com': 'google.com'
};
const PLAYWRIGHT_DEFAULT_SEARCH_PROVIDER = 'google';
const PLAYWRIGHT_SEARCH_PROVIDERS = {
    google: {
        key: 'google',
        label: 'Google Search',
        host: 'google.com',
        buildUrl(query) {
            const trimmed = String(query || '').trim();
            return `https://www.google.com/search?q=${encodeURIComponent(trimmed)}&hl=en`;
        }
    },
    duckduckgo: {
        key: 'duckduckgo',
        label: 'DuckDuckGo Search',
        host: 'duckduckgo.com',
        buildUrl(query) {
            const trimmed = String(query || '').trim();
            return `https://duckduckgo.com/?q=${encodeURIComponent(trimmed)}`;
        }
    },
    bing: {
        key: 'bing',
        label: 'Bing Search',
        host: 'bing.com',
        buildUrl(query) {
            const trimmed = String(query || '').trim();
            return `https://www.bing.com/search?q=${encodeURIComponent(trimmed)}`;
        }
    }
};
const PLAYWRIGHT_SEARCH_PROVIDER_KEYS = Object.keys(PLAYWRIGHT_SEARCH_PROVIDERS);
const PLAYWRIGHT_ALLOWED_SECONDARY_HOSTS = new Set(PLAYWRIGHT_SEARCH_PROVIDER_KEYS.map(key => PLAYWRIGHT_SEARCH_PROVIDERS[key].host));
let chatSessions = [];
let activeChatId = null;
let isRestoringChat = false;
const playwrightRenderCache = new Map();
let playwrightHelperMode = 'embedded';
let playwrightServerInput = null;
let playwrightModeRadios = [];

const OLLAMA_DEFAULT_TOOLS = [
    {
        type: 'function',
        function: {
            name: 'get_current_time',
            description: 'Return the current system time. Use when the user asks for the time or when fresh timestamps are useful.',
            parameters: {
                type: 'object',
                properties: {
                    format: {
                        type: 'string',
                        description: 'Optional format. Use "iso" for ISO-8601, or "locale" for a human readable local time.',
                        enum: ['iso', 'locale']
                    }
                },
                additionalProperties: false
            }
        }
        },
        {
            type: 'function',
            function: {
                name: 'render_with_playwright',
                description: 'Render a URL or live web search with the Playwright helper to capture dynamic HTML content. Use for JavaScript-heavy pages, realtime site checks, or when you need search results.',
                parameters: {
                    type: 'object',
                    properties: {
                        url: {
                            type: 'string',
                            description: 'The absolute URL to render (http/https).'
                        },
                        query: {
                            type: 'string',
                            description: 'Search query to run when you need live web results. When provided, the helper will construct the search URL (defaults to Google).'
                        },
                        search_provider: {
                            type: 'string',
                            description: 'Optional search provider to pair with the query parameter. Supported values: google (default), duckduckgo, bing.',
                            enum: PLAYWRIGHT_SEARCH_PROVIDER_KEYS
                        },
                        wait_time: {
                            type: 'integer',
                            description: 'Optional wait time in milliseconds before capturing the page. Defaults to the UI wait time slider.',
                            minimum: 0,
                        maximum: 120000
                    },
                    include_images: {
                        type: 'boolean',
                        description: 'Override whether image alt text should be captured.'
                    },
                    include_links: {
                        type: 'boolean',
                        description: 'Override whether link text should be captured.'
                    },
                    include_metadata: {
                        type: 'boolean',
                        description: 'Override whether metadata should be captured.'
                    },
                    clean_content: {
                        type: 'boolean',
                        description: 'Override whether to clean text content before returning.'
                    }
                },
                additionalProperties: false
            }
        }
    }
];

let currentTheme = 'dark';

function updateThemeToggle(theme) {
    const toggle = document.getElementById('themeToggle');
    if (!toggle) {
        return;
    }
    if (theme === 'light') {
        toggle.textContent = '🌙';
        toggle.setAttribute('aria-label', 'Switch to dark theme');
    } else {
        toggle.textContent = '☀️';
        toggle.setAttribute('aria-label', 'Switch to light theme');
    }
}

function applyTheme(theme, persist = true) {
    currentTheme = theme === 'light' ? 'light' : 'dark';
    const doc = document.documentElement;
    doc.dataset.theme = currentTheme;
    doc.style.colorScheme = currentTheme;
    updateThemeToggle(currentTheme);
    if (persist) {
        try {
            localStorage.setItem(THEME_STORAGE_KEY, currentTheme);
        } catch (storageError) {
            console.warn('Unable to persist theme preference:', storageError);
        }
    }
}

function initializeTheme() {
    let storedTheme = null;
    try {
        storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    } catch (storageError) {
        console.warn('Unable to access theme preference from storage:', storageError);
    }

    let initialTheme = storedTheme;
    if (!initialTheme) {
        initialTheme = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches
            ? 'light'
            : 'dark';
    }

    applyTheme(initialTheme, false);

    const toggle = document.getElementById('themeToggle');
    if (toggle) {
        toggle.addEventListener('click', () => {
            const next = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(next);
        });
    }

    if (window.matchMedia) {
        try {
            const media = window.matchMedia('(prefers-color-scheme: light)');
            const listener = event => {
                try {
                    if (localStorage.getItem(THEME_STORAGE_KEY)) {
                        return;
                    }
                } catch (storageError) {
                    // ignore storage issues
                }
                applyTheme(event.matches ? 'light' : 'dark', false);
            };
            if (media.addEventListener) {
                media.addEventListener('change', listener);
            } else if (media.addListener) {
                media.addListener(listener);
            }
        } catch (error) {
            console.warn('Unable to observe system theme changes:', error);
        }
    }
}

initializeTheme();

function escapeHtml(value) {
    return value.replace(/[&<>"']/g, function(char) {
        switch (char) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return char;
        }
    });
}

const conversationEl = document.getElementById('chatMessages');
const chatHistoryListEl = document.getElementById('chatHistoryList');
let pendingAssistantMessage = null;
let statusMessageEl = null;

function generateId(prefix = 'id') {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return `${prefix}-${crypto.randomUUID()}`;
    }
    return `${prefix}-${Date.now().toString(36)}-${Math.floor(Math.random() * 1e6)}`;
}

function appendConversationMessage(role, html, options = {}) {
    if (!conversationEl) return null;
    const { skipHistory = false, messageId = null } = options;
    const wrapper = document.createElement('div');
    wrapper.classList.add('conversation-message');
    const roleParts = role.split(/\s+/).filter(Boolean);
    const primaryRole = roleParts[0] || 'assistant';
    roleParts.forEach(part => wrapper.classList.add(part));
    const bubble = document.createElement('div');
    bubble.className = 'conversation-bubble';
    bubble.dataset.role = primaryRole;
    bubble.innerHTML = html;
    scrubTokensInElement(bubble);

    const assignedId = messageId || generateId('msg');
    wrapper.dataset.messageId = assignedId;

    const isStatus = roleParts.includes('status');
    if (!isStatus) {
        const avatar = document.createElement('div');
        avatar.className = 'conversation-avatar';
        avatar.textContent = primaryRole === 'user' ? '🧑' : '🤖';
        wrapper.appendChild(avatar);
    }

    wrapper.appendChild(bubble);
    conversationEl.appendChild(wrapper);
    if (!skipHistory) {
        recordChatMessage(assignedId, role, html);
    }
    requestAnimationFrame(scrollConversationToEnd);
    return wrapper;
}

function updateConversationMessage(messageEl, html, options = {}) {
    if (!messageEl) return;
    const bubble = messageEl.querySelector('.conversation-bubble');
    if (bubble) {
        bubble.innerHTML = html;
        scrubTokensInElement(bubble);
        if (!options.skipHistory) {
            const messageId = messageEl.dataset.messageId;
            if (messageId) {
                updateChatMessageRecord(messageId, html);
            }
        }
        requestAnimationFrame(scrollConversationToEnd);
    }
}

function renderUserMessage(text) {
    return `
        <div class="bubble-header">
            <span class="bubble-label">You</span>
            <div class="bubble-actions">
                <button type="button" class="bubble-copy" data-copy="user">Copy</button>
            </div>
        </div>
        <div class="bubble-text">${escapeHtml(text).replace(/\n/g, '<br>')}</div>
    `;
}

function renderAssistantLoading(text = 'Working…') {
    return `
        <div class="bubble-header">
            <span class="bubble-label">Assistant</span>
            <div class="bubble-actions">
                <span class="assistant-loading-inline"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
            </div>
        </div>
        <div class="assistant-llm">${escapeHtml(text)}</div>
    `;
}

function renderAssistantResponse(llmHtml, data, extractionIndex) {
    const cleaned = cleanPlaceholderArtifacts(llmHtml);
    const detailsHtml = data ? renderExtractionDetails(data, extractionIndex) : '';
    return `
        <div class="bubble-header">
            <span class="bubble-label">Assistant</span>
            <div class="bubble-actions">
                <button type="button" class="bubble-copy" data-copy="assistant">Copy</button>
            </div>
        </div>
        <div class="assistant-llm">${cleaned}</div>
        ${detailsHtml}
    `;
}

function renderToolUsageSummary(executions) {
    if (!Array.isArray(executions) || executions.length === 0) {
        return '';
    }
    const items = executions.map((execution, index) => {
        const name = escapeHtml(execution.name || `Tool ${index + 1}`);
        const display = escapeHtml(execution.display || execution.content || '');
        const itemClass = execution.error ? ' class="assistant-tool-error"' : '';
        const meta = [];
        if (execution.cached) {
            meta.push('cached');
        }
        if (execution.forceRefreshed) {
            meta.push('refreshed');
        }
        if (execution.searchProvider) {
            const providerLabel = getSearchProviderConfig(execution.searchProvider).label;
            meta.push(providerLabel);
        }
        const suffix = meta.length ? ` <span class="assistant-tool-meta">(${meta.join(', ')})</span>` : '';
        return `<li${itemClass}><span class="assistant-tool-name">${name}</span> → ${display}${suffix}</li>`;
    }).join('');
    return `
        <div class="assistant-tool-usage">
            <div class="assistant-tool-label">Tools used</div>
            <ul>${items}</ul>
        </div>
    `;
}


function formatToolArgValue(value) {
    if (value === null || value === undefined) {
        return '';
    }
    if (typeof value === 'string') {
        return truncateText(value, 140);
    }
    if (typeof value === 'number' || typeof value === 'boolean') {
        return String(value);
    }
    try {
        return truncateText(JSON.stringify(value), 140);
    } catch {
        return '';
    }
}

function describeToolCall(toolCall) {
    const name = toolCall?.function?.name || toolCall?.name || 'tool';
    let parsedArgs = {};
    try {
        parsedArgs = parseToolArguments(toolCall?.function?.arguments ?? toolCall?.arguments ?? {});
    } catch (error) {
        console.warn('Unable to parse tool arguments for display:', error);
        parsedArgs = {};
    }
    const details = [];
    const urlValue = parsedArgs.url || parsedArgs.href;
    if (urlValue) {
        details.push({ label: 'URL', value: formatToolArgValue(urlValue) });
    }
    if (parsedArgs.query) {
        details.push({ label: 'Query', value: formatToolArgValue(parsedArgs.query) });
    }
    const providerKey = parsedArgs.search_provider || parsedArgs.searchProvider;
    if (providerKey) {
        const provider = getSearchProviderConfig(providerKey);
        const providerLabel = provider ? provider.label : formatToolArgValue(providerKey);
        details.push({ label: 'Search provider', value: providerLabel });
    }
    const waitTimeValue = parsedArgs.wait_time ?? parsedArgs.waitTime;
    if (waitTimeValue !== undefined) {
        details.push({ label: 'Wait time', value: `${waitTimeValue} ms` });
    }
    ['include_images', 'include_links', 'include_metadata', 'clean_content', 'block_media', 'use_cache'].forEach(key => {
        if (parsedArgs[key] !== undefined) {
            const normalisedLabel = key.replace(/_/g, ' ');
            details.push({
                label: `${normalisedLabel.charAt(0).toUpperCase()}${normalisedLabel.slice(1)}`,
                value: String(parsedArgs[key])
            });
        }
    });
    if (!details.length && parsedArgs && typeof parsedArgs === 'object') {
        Object.entries(parsedArgs)
            .slice(0, 3)
            .forEach(([key, value]) => {
                details.push({ label: key, value: formatToolArgValue(value) });
            });
    }
    return { name, details };
}

function extractExecutionMessage(execution) {
    if (!execution) {
        return '';
    }
    if (typeof execution.display === 'string' && execution.display.trim()) {
        return execution.display.trim();
    }
    if (typeof execution.content === 'string') {
        try {
            const parsed = JSON.parse(execution.content);
            if (parsed && typeof parsed.error === 'string' && parsed.error.trim()) {
                return parsed.error.trim();
            }
        } catch {
            // ignore JSON parse errors
        }
    }
    return '';
}

function renderToolDecision(descriptor, state = {}) {
    const { name, details } = descriptor;
    const detailHtml = details.length
        ? `<ul class="assistant-tool-decision-args">${details
              .map(detail => `<li><strong>${escapeHtml(detail.label)}:</strong> ${escapeHtml(detail.value || '')}</li>`)
              .join('')}</ul>`
        : `<div class="assistant-tool-decision-details">No arguments provided.</div>`;

    let statusClass = 'assistant-tool-decision-status';
    let statusContent = '';
    if (state.status === 'error') {
        statusClass += ' error';
        statusContent = `⚠️ <span>${escapeHtml(state.message || 'Tool execution failed.')}</span>`;
    } else if (state.status === 'success') {
        statusClass += ' success';
        statusContent = `✅ <span>${escapeHtml(state.message || 'Completed successfully.')}</span>`;
    } else {
        const spinner = '<span class="assistant-loading-inline"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
        statusContent = `${spinner}<span>${escapeHtml(state.message || 'Running…')}</span>`;
    }

    const extraLines = Array.isArray(state.detailLines) ? state.detailLines.filter(Boolean) : [];
    const extrasHtml = extraLines.length
        ? `<div class="assistant-tool-decision-details">${extraLines.map(line => escapeHtml(line)).join('<br>')}</div>`
        : '';

    return `
        <div class="assistant-tool-decision">
            <div class="assistant-tool-decision-title">Calling tool: <code>${escapeHtml(name)}</code></div>
            ${detailHtml}
            <div class="${statusClass}">${statusContent}</div>
            ${extrasHtml}
        </div>
    `;
}

function announceToolDecision(toolCall) {
    if (!conversationEl) {
        return null;
    }
    try {
        const descriptor = describeToolCall(toolCall);
        const html = renderToolDecision(descriptor, { status: 'running' });
        return appendConversationMessage('assistant status tool-decision', html, { skipHistory: true });
    } catch (error) {
        console.warn('Unable to announce tool decision:', error);
        return null;
    }
}

function updateToolDecisionMessage(messageEl, toolCall, execution, errorInfo) {
    if (!messageEl) {
        return;
    }
    try {
        const descriptor = describeToolCall(toolCall);
        const explicitError = typeof errorInfo === 'string'
            ? errorInfo
            : errorInfo && errorInfo.message
                ? errorInfo.message
                : '';
        const computedMessage = explicitError || extractExecutionMessage(execution);
        const isError = Boolean(explicitError) || Boolean(execution && execution.error);
        const detailLines = [];
        if (execution) {
            const flags = [];
            if (execution.cached) {
                flags.push('cached result');
            }
            if (execution.forceRefreshed || execution.force_refreshed) {
                flags.push('force refreshed');
            }
            if (execution.searchQuery) {
                detailLines.push(`Search query: ${truncateText(execution.searchQuery, 80)}`);
            }
            if (execution.searchProvider || execution.search_provider) {
                const provider = getSearchProviderConfig(execution.searchProvider || execution.search_provider);
                if (provider) {
                    detailLines.push(`Search provider: ${provider.label}`);
                }
            }
            if (flags.length) {
                detailLines.push(`Flags: ${flags.join(', ')}`);
            }
        }
        const state = {
            status: isError ? 'error' : 'success',
            message: computedMessage || (isError ? 'Tool execution failed.' : 'Completed successfully.'),
            detailLines
        };
        const html = renderToolDecision(descriptor, state);
        updateConversationMessage(messageEl, html, { skipHistory: true });
    } catch (error) {
        console.warn('Unable to update tool decision message:', error);
    }
}

function buildToolFallbackContent(execution, reason = '') {
    if (!execution) {
        return '';
    }
    const reasonLine = reason || 'Tool loop stopped after repeated tool calls.';
    if (execution.name === 'render_with_playwright') {
        try {
            const payload = JSON.parse(execution.content || '{}');
            const summary = typeof payload.summary === 'string' ? normalizeModelOutput(payload.summary) : '';
            const markdown = typeof payload.markdown === 'string' ? payload.markdown : '';
            const body = summary || markdown || execution.display || execution.content || '';
            return [reasonLine, '', body].filter(Boolean).join('\n');
        } catch (error) {
            console.warn('Unable to parse Playwright tool payload for fallback content:', error);
        }
    }
    const body = execution.display || execution.content || '';
    return [reasonLine, '', body].filter(Boolean).join('\n');
}

function escapeAttribute(value) {
    return escapeHtml(String(value)).replace(/"/g, '&quot;');
}

function isLikelyFallbackHtml(html, hostname) {
    if (!html) {
        return true;
    }
    const canonicalHost = canonicalizeHostname(hostname || '');
    const lower = html.toLowerCase();

    if (canonicalHost === 'youtube.com') {
        if (/ytInitialData/.test(html) || /ytInitialPlayerResponse/.test(html)) {
            return false;
        }
        if (html.length > 20000 && lower.includes('ytmusic')) {
            return false;
        }
        return (
            lower.includes('before you continue to youtube') ||
            lower.includes('consent') ||
            lower.includes('enable javascript') ||
            lower.includes('403 forbidden') ||
            html.length < 20000
        );
    }

    const fallbackIndicators = [
        'enable javascript',
        'javascript is required',
        '403 forbidden',
        'captcha',
        'access denied',
        'api is locked down'
    ];

    if (fallbackIndicators.some(indicator => lower.includes(indicator))) {
        return true;
    }

    return html.length < 1500;
}

function stripHtmlToText(html) {
    if (!html) {
        return '';
    }
    const temp = document.createElement('div');
    temp.innerHTML = html;
    return (temp.textContent || temp.innerText || '').trim();
}

function cloneExtractionData(data) {
    if (!data) {
        return null;
    }
    if (typeof structuredClone === 'function') {
        try {
            return structuredClone(data);
        } catch (error) {
            // fall back
        }
    }
    return JSON.parse(JSON.stringify(data));
}

function getActiveChatSession() {
    if (!activeChatId) {
        return null;
    }
    return chatSessions.find(session => session && session.id === activeChatId) || null;
}

function formatSessionTimestamp(isoString) {
    if (!isoString) {
        return '';
    }
    const date = new Date(isoString);
    if (Number.isNaN(date.getTime())) {
        return '';
    }
    const diffMs = Date.now() - date.getTime();
    const minute = 60 * 1000;
    const hour = 60 * minute;
    const day = 24 * hour;
    if (diffMs < minute) {
        return 'Just now';
    }
    if (diffMs < hour) {
        const minutes = Math.round(diffMs / minute);
        return `${minutes} min${minutes === 1 ? '' : 's'} ago`;
    }
    if (diffMs < day) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    return date.toLocaleDateString();
}

function saveChatSessions() {
    try {
        chatSessions = chatSessions
            .filter(session => session && session.id)
            .map(session => ({
                id: session.id,
                title: session.title || CHAT_DEFAULT_TITLE,
                createdAt: session.createdAt || new Date().toISOString(),
                updatedAt: session.updatedAt || new Date().toISOString(),
                messages: Array.isArray(session.messages) ? session.messages : [],
                extractions: Array.isArray(session.extractions) ? session.extractions : [],
                preview: session.preview || ''
            }));
        chatSessions.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
        if (chatSessions.length > CHAT_HISTORY_LIMIT) {
            chatSessions = chatSessions.slice(0, CHAT_HISTORY_LIMIT);
        }
        localStorage.setItem(CHAT_HISTORY_STORAGE_KEY, JSON.stringify(chatSessions));
        if (activeChatId) {
            localStorage.setItem(ACTIVE_CHAT_STORAGE_KEY, activeChatId);
        }
    } catch (error) {
        console.warn('Unable to persist chat history:', error);
    }
}

function renderChatHistoryList() {
    if (!chatHistoryListEl) {
        return;
    }
    if (!chatSessions.length) {
        chatHistoryListEl.innerHTML = '<li class="empty">No chats yet. Start one!</li>';
        return;
    }
    const items = chatSessions.map(session => {
        const isActive = session.id === activeChatId;
        const title = escapeHtml(session.title || CHAT_DEFAULT_TITLE);
        const preview = escapeHtml(session.preview || '');
        const timestamp = escapeHtml(formatSessionTimestamp(session.updatedAt));
        const metaCombined = timestamp ? (preview ? `${timestamp} • ${preview}` : timestamp) : preview;
        const metaText = metaCombined || escapeHtml('No messages yet');
        return `
            <li class="${isActive ? 'active' : ''}" data-chat-id="${escapeAttribute(session.id)}">
                <button type="button" class="sidebar-chat-item" data-chat-id="${escapeAttribute(session.id)}">
                    <span class="sidebar-chat-title">${title}</span>
                    <span class="sidebar-chat-meta">${metaText}</span>
                </button>
                <button type="button" class="sidebar-chat-delete" title="Delete chat" aria-label="Delete chat" data-chat-delete="${escapeAttribute(session.id)}">×</button>
            </li>
        `;
    }).join('');
    chatHistoryListEl.innerHTML = items;
}

function ensureActiveChatSession() {
    if (!Array.isArray(chatSessions)) {
        chatSessions = [];
    }
    if (!chatSessions.length) {
        const session = createChatSession(CHAT_DEFAULT_TITLE);
        chatSessions = [session];
        activeChatId = session.id;
        saveChatSessions();
    }
    if (!activeChatId || !chatSessions.some(session => session.id === activeChatId)) {
        activeChatId = chatSessions[0].id;
        saveChatSessions();
    }
}

function recordChatMessage(messageId, role, html) {
    if (isRestoringChat) {
        return;
    }
    const session = getActiveChatSession();
    if (!session || !messageId) {
        return;
    }
    const normalizedRole = (role || '').toString();
    if (normalizedRole.includes('status')) {
        return;
    }
    const timestamp = new Date().toISOString();
    let message = session.messages.find(item => item.id === messageId);
    if (!message) {
        message = {
            id: messageId,
            role: normalizedRole,
            html,
            createdAt: timestamp,
            updatedAt: timestamp
        };
        session.messages.push(message);
    } else {
        message.html = html;
        message.updatedAt = timestamp;
    }
    session.updatedAt = timestamp;

    const textContent = stripHtmlToText(html).replace(/\s+/g, ' ').trim();
    if (normalizedRole.startsWith('user')) {
        if (!session.title || session.title === CHAT_DEFAULT_TITLE) {
            session.title = textContent ? truncateText(textContent, 60) : CHAT_DEFAULT_TITLE;
        }
        if (textContent) {
            session.preview = truncateText(textContent, 80);
        }
    } else if (normalizedRole.startsWith('assistant') && textContent) {
        session.preview = truncateText(textContent, 80);
    }

    saveChatSessions();
    renderChatHistoryList();
}

function updateChatMessageRecord(messageId, html) {
    if (isRestoringChat) {
        return;
    }
    const session = getActiveChatSession();
    if (!session || !messageId) {
        return;
    }
    const message = session.messages.find(item => item.id === messageId);
    if (!message) {
        return;
    }
    message.html = html;
    message.updatedAt = new Date().toISOString();
    session.updatedAt = message.updatedAt;

    if (message.role && message.role.startsWith('assistant')) {
        const textContent = stripHtmlToText(html).replace(/\s+/g, ' ').trim();
        if (textContent) {
            session.preview = truncateText(textContent, 80);
        }
    }

    saveChatSessions();
    renderChatHistoryList();
}

function renderActiveChatConversation() {
    if (!conversationEl) {
        return;
    }
    const session = getActiveChatSession();
    isRestoringChat = true;
    conversationEl.innerHTML = '';
    statusMessageEl = null;
    pendingAssistantMessage = null;
    extractionHistory.length = 0;
    extractedData = null;

    if (session) {
        (session.messages || []).forEach(message => {
            appendConversationMessage(message.role, message.html, { skipHistory: true, messageId: message.id });
        });
        const storedExtractions = session.extractions || [];
        storedExtractions.forEach(record => {
            const clone = cloneExtractionData(record);
            if (clone) {
                const index = extractionHistory.push(clone) - 1;
                clone.extractionIndex = index;
            }
        });
        if (extractionHistory.length) {
            extractedData = extractionHistory[extractionHistory.length - 1];
        }
    }

    isRestoringChat = false;
    updateLlmSendAvailability();
    hideMessages();
    setLlmStatus('', '');
    hideProgress();
}

function getEmbeddedPlaywrightEndpoint() {
    let origin = 'http://localhost:3050';
    if (window.location && window.location.origin && window.location.origin !== 'null') {
        origin = window.location.origin.replace(/\/$/, '');
    }
    return `${origin}${PLAYWRIGHT_EMBEDDED_ENDPOINT}`;
}

function applyPlaywrightMode(mode, persist = true) {
    const normalized = mode === 'container' ? 'container' : 'embedded';
    playwrightHelperMode = normalized;
    if (persist) {
        try {
            localStorage.setItem(PLAYWRIGHT_MODE_STORAGE_KEY, normalized);
        } catch (error) {
            console.warn('Unable to persist Playwright helper mode:', error);
        }
    }
    playwrightRenderCache.clear();
    playwrightModeRadios.forEach(radio => {
        if (radio.value === normalized) {
            radio.checked = true;
        } else if (normalized === 'embedded' && !radio.value) {
            radio.checked = true;
        }
    });
    if (playwrightServerInput) {
        const containerSelected = normalized === 'container';
        playwrightServerInput.disabled = !containerSelected;
        if (!containerSelected) {
            playwrightServerInput.setAttribute('placeholder', `${getEmbeddedPlaywrightEndpoint()}`);
        } else {
            playwrightServerInput.setAttribute('placeholder', playwrightServerInput.dataset.defaultPlaceholder || 'http://localhost:3050');
        }
    }
}

function initializePlaywrightMode() {
    playwrightModeRadios = Array.from(document.querySelectorAll('input[name="playwrightMode"]'));
    let storedMode = 'embedded';
    try {
        const saved = localStorage.getItem(PLAYWRIGHT_MODE_STORAGE_KEY);
        if (saved) {
            storedMode = saved;
        }
    } catch (error) {
        console.warn('Unable to load Playwright helper mode:', error);
    }
    applyPlaywrightMode(storedMode, false);
    playwrightModeRadios.forEach(radio => {
        radio.addEventListener('change', event => {
            if (event.target.checked) {
                applyPlaywrightMode(event.target.value);
            }
        });
    });
}

function createChatSession(title = CHAT_DEFAULT_TITLE) {
    const timestamp = new Date().toISOString();
    return {
        id: generateId('chat'),
        title: title || CHAT_DEFAULT_TITLE,
        createdAt: timestamp,
        updatedAt: timestamp,
        messages: [],
        extractions: [],
        preview: ''
    };
}

function startNewChat() {
    const session = createChatSession();
    chatSessions.unshift(session);
    if (chatSessions.length > CHAT_HISTORY_LIMIT) {
        chatSessions.length = CHAT_HISTORY_LIMIT;
    }
    activeChatId = session.id;
    saveChatSessions();
    renderChatHistoryList();
    renderActiveChatConversation();
    if (taskInputElement) {
        taskInputElement.value = '';
        taskInputElement.focus();
    }
}

function switchToChatSession(chatId) {
    if (!chatId || chatId === activeChatId) {
        return;
    }
    if (!chatSessions.some(session => session.id === chatId)) {
        return;
    }
    activeChatId = chatId;
    saveChatSessions();
    renderChatHistoryList();
    renderActiveChatConversation();
    if (taskInputElement) {
        taskInputElement.focus();
    }
}

function deleteChatSession(chatId) {
    if (!chatId) {
        return;
    }
    const index = chatSessions.findIndex(session => session.id === chatId);
    if (index === -1) {
        return;
    }
    chatSessions.splice(index, 1);
    if (activeChatId === chatId) {
        if (chatSessions.length) {
            activeChatId = chatSessions[0].id;
        } else {
            const session = createChatSession();
            chatSessions = [session];
            activeChatId = session.id;
        }
    }
    saveChatSessions();
    renderChatHistoryList();
    renderActiveChatConversation();
    if (taskInputElement) {
        taskInputElement.focus();
    }
}

function initializeChatHistory() {
    try {
        const stored = localStorage.getItem(CHAT_HISTORY_STORAGE_KEY);
        if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
                chatSessions = parsed;
            }
        }
    } catch (error) {
        console.warn('Unable to load chat history from storage:', error);
    }
    try {
        const storedActiveId = localStorage.getItem(ACTIVE_CHAT_STORAGE_KEY);
        if (storedActiveId) {
            activeChatId = storedActiveId;
        }
    } catch (error) {
        console.warn('Unable to load active chat id from storage:', error);
    }
    ensureActiveChatSession();
    saveChatSessions();
    renderChatHistoryList();
    renderActiveChatConversation();
}

function clearChatHistory() {
    const confirmed = window.confirm('Clear all chat history? This cannot be undone.');
    if (!confirmed) {
        return;
    }
    chatSessions = [];
    activeChatId = null;
    playwrightRenderCache.clear();
    try {
        localStorage.removeItem(CHAT_HISTORY_STORAGE_KEY);
        localStorage.removeItem(ACTIVE_CHAT_STORAGE_KEY);
    } catch (error) {
        console.warn('Unable to remove chat history from storage:', error);
    }
    const session = createChatSession();
    chatSessions = [session];
    activeChatId = session.id;
    saveChatSessions();
    renderChatHistoryList();
    renderActiveChatConversation();
    hideMessages();
    setLlmStatus('', '');
    hideProgress();
    if (taskInputElement) {
        taskInputElement.value = '';
        taskInputElement.focus();
    }
}

function storeExtractionRecord(extraction) {
    if (isRestoringChat || !extraction) {
        return;
    }
    const session = getActiveChatSession();
    if (!session) {
        return;
    }
    const clone = cloneExtractionData(extraction);
    if (!clone) {
        return;
    }
    delete clone.extractionIndex;
    session.extractions.push(clone);
    session.updatedAt = new Date().toISOString();
    saveChatSessions();
    renderChatHistoryList();
}

function formatOllamaError(status, rawText) {
    const segments = [];
    const statusLabel = typeof status === 'number' ? `HTTP ${status}` : '';
    let detail = '';

    if (rawText) {
        let parsed = null;
        try {
            parsed = JSON.parse(rawText);
        } catch (error) {
            parsed = null;
        }
        if (parsed && typeof parsed === 'object') {
            const code = parsed.StatusCode || parsed.statusCode || parsed.code;
            const statusText = parsed.Status || parsed.status;
            const errorMessage = parsed.error || parsed.message || parsed.detail;
            if (code && !statusLabel) {
                segments.push(`HTTP ${code}`);
            } else if (statusLabel) {
                segments.push(statusLabel + (statusText ? ` (${statusText})` : ''));
            } else if (statusText) {
                segments.push(statusText);
            }
            if (errorMessage) {
                detail = typeof errorMessage === 'string' ? errorMessage : JSON.stringify(errorMessage);
            } else if (parsed.details) {
                detail = typeof parsed.details === 'string' ? parsed.details : JSON.stringify(parsed.details);
            }
        } else {
            if (statusLabel) {
                segments.push(statusLabel);
            }
            detail = rawText;
        }
    } else if (statusLabel) {
        segments.push(statusLabel);
    }

    if (detail) {
        segments.push(detail);
    }

    const baseMessage = segments.filter(Boolean).join(': ').trim() || 'Unknown error returned by Ollama.';
    let suggestion = '';
    if (typeof status === 'number') {
        if (status === 502) {
            suggestion = 'Upstream error. Restart the Ollama server or the selected model and try again.';
        } else if (status === 500) {
            suggestion = 'Internal server error. Restart Ollama or inspect the model logs for crashes.';
        } else if (status === 404) {
            suggestion = 'Endpoint not found. Ensure Ollama is running and supports the /api/chat endpoint.';
        } else if (status === 401 || status === 403) {
            suggestion = 'Authentication error. Confirm this UI is permitted to access Ollama.';
        }
    }

    return suggestion ? `${baseMessage}\n${suggestion}` : baseMessage;
}

initializeChatHistory();

if (chatHistoryListEl) {
    chatHistoryListEl.addEventListener('click', event => {
        const deleteButton = event.target.closest('[data-chat-delete]');
        if (deleteButton) {
            const chatId = deleteButton.getAttribute('data-chat-delete');
            event.preventDefault();
            deleteChatSession(chatId);
            event.stopPropagation();
            return;
        }
        const item = event.target.closest('[data-chat-id]');
        if (item) {
            const chatId = item.getAttribute('data-chat-id');
            switchToChatSession(chatId);
        }
    });
}

function scrubTokensInElement(root) {
    if (!root) return;
    try {
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
        const toUpdate = [];
        while (walker.nextNode()) {
            toUpdate.push(walker.currentNode);
        }
        const re1 = /@@[^@\s][^@]*@@/g; // tokens wrapped in @@..@@
        const re2 = /__[_A-Z]+[0-9_]*__/gi; // __BOLD0__, __EM1__, etc
        const re3 = /_([A-Z]+[0-9]*)_/g; // _BOLD0_
        for (const node of toUpdate) {
            const before = node.nodeValue;
            const after = before.replace(re1, '').replace(re2, '').replace(re3, '');
            if (after !== before) {
                node.nodeValue = after;
            }
        }
        if (root.innerHTML) {
            const cleaned = cleanPlaceholderArtifacts(root.innerHTML);
            if (cleaned !== root.innerHTML) {
                root.innerHTML = cleaned;
            }
        }
    } catch (err) {
        console.warn('scrubTokensInElement failed:', err);
    }
}

function stripPlaceholderTokens(value) {
    if (typeof value !== 'string') {
        return value;
    }
    return value
        .replace(/@@[A-Z0-9_:-]+@@/gi, '')
        .replace(/__[_A-Z]+[0-9_]*__/gi, '')
        .replace(/_([A-Z]+[0-9]*)_/g, '');
}

function cleanPlaceholderArtifacts(html) {
    if (typeof html !== 'string') {
        return html;
    }
    return stripPlaceholderTokens(html).replace(/@@[^@\s][^@]*@@/g, '');
}

function getOverrideValue(source, keys) {
    if (!source || typeof source !== 'object') {
        return undefined;
    }
    for (const key of keys) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            return source[key];
        }
    }
    return undefined;
}

function coerceBoolean(value, fallback) {
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'string') {
        if (/^(true|1|yes|on)$/i.test(value)) {
            return true;
        }
        if (/^(false|0|no|off)$/i.test(value)) {
            return false;
        }
    }
    return fallback;
}

function coercePositiveInteger(value, fallback) {
    const number = Number.parseInt(value, 10);
    if (Number.isFinite(number) && number > 0) {
        return number;
    }
    return fallback;
}

async function requestPlaywrightHtml(url, overrides = {}) {
    const targetUrl = String(url || '').trim();
    if (!targetUrl) {
        throw new Error('No URL provided for Playwright rendering.');
    }

    const helperMode = playwrightHelperMode || 'embedded';
    const endpoint = getPlaywrightEndpoint(helperMode);

    const waitTimeInput = document.getElementById('waitTime');
    const defaultWait = coercePositiveInteger(waitTimeInput?.value, 3000);
    const overrideWait = getOverrideValue(overrides, ['wait_time', 'waitTime']);
    const rawWait = coercePositiveInteger(overrideWait, defaultWait);
    const minWait = helperMode === 'embedded' ? 200 : 350;
    const maxWait = helperMode === 'embedded' ? 1200 : 2000;
    const waitTime = Math.max(minWait, Math.min(rawWait, maxWait));

    const includeImagesDefault = document.getElementById('includeImages')?.checked ?? false;
    const includeLinksDefault = document.getElementById('includeLinks')?.checked ?? false;
    const includeMetadataDefault = document.getElementById('includeMetadata')?.checked ?? true;
    const cleanContentDefault = document.getElementById('cleanContent')?.checked ?? true;
    const blockMediaDefault = document.getElementById('blockMedia')?.checked ?? false;

    const includeImages = coerceBoolean(getOverrideValue(overrides, ['include_images', 'includeImages']), includeImagesDefault);
    const includeLinks = coerceBoolean(getOverrideValue(overrides, ['include_links', 'includeLinks']), includeLinksDefault);
    const includeMetadata = coerceBoolean(getOverrideValue(overrides, ['include_metadata', 'includeMetadata']), includeMetadataDefault);
    const cleanContent = coerceBoolean(getOverrideValue(overrides, ['clean_content', 'cleanContent']), cleanContentDefault);
    const blockMedia = coerceBoolean(getOverrideValue(overrides, ['block_media', 'blockMedia']), blockMediaDefault);

    const cacheKey = `${helperMode}::${endpoint}::${targetUrl}::${blockMedia ? 'block' : 'allow'}`;
    const useCache = coerceBoolean(getOverrideValue(overrides, ['use_cache', 'useCache']), true);
    const cachedEntry = useCache ? playwrightRenderCache.get(cacheKey) : null;
    if (cachedEntry && Date.now() - cachedEntry.timestamp < PLAYWRIGHT_CACHE_TTL_MS) {
        return { ...cachedEntry.payload, cached: true };
    }

    let response;
    try {
        response = await fetch(endpoint, {
            method: 'POST',
            mode: 'cors',
            credentials: 'omit',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                url: targetUrl,
                waitTime,
                mode: helperMode,
                options: {
                    includeImages,
                    includeLinks,
                    includeMetadata,
                    cleanContent,
                    blockMedia,
                    warmBrowser: true,
                    useCache
                }
            })
        });
    } catch (networkError) {
        const message = networkError?.message || '';
        if (message.includes('Failed to fetch') || message.includes('NetworkError')) {
            showPlaywrightInstructions(message);
            const error = new Error('Playwright server not reachable. See instructions below to set up browser automation.');
            error.code = 'PLAYWRIGHT_HELPER_UNREACHABLE';
            throw error;
        }
        throw networkError;
    }

    if (!response.ok) {
        if ([404, 405].includes(response.status)) {
            showPlaywrightInstructions(`The Playwright helper server responded with status ${response.status}. Confirm it is running at ${endpoint} and accepts POST requests.`);
            const statusText = response.status === 405 ? 'Method Not Allowed' : 'Not Found';
            throw new Error(`Playwright helper server returned ${response.status} (${statusText}).`);
        }
        const errorText = await response.text();
        throw new Error(`Playwright server error: ${response.status}${errorText ? ` - ${errorText}` : ''}`);
    }

    let result;
    try {
        result = await response.json();
    } catch (error) {
        throw new Error('Playwright server returned an invalid JSON payload.');
    }

    if (!result || !result.success) {
        throw new Error(result?.error || 'Playwright extraction failed.');
    }

    const MAX_HTML_LENGTH = 120000;
    const html = String(result.html || '');
    const truncated = html.length > MAX_HTML_LENGTH;
    const trimmedHtml = truncated ? `${html.slice(0, MAX_HTML_LENGTH)}<!-- Truncated -->` : html;

    let normalizedMetadata = null;
    if (result.metadata && typeof result.metadata === 'object') {
        try {
            normalizedMetadata = JSON.parse(JSON.stringify(result.metadata));
        } catch (metadataError) {
            console.warn('Unable to serialise Playwright metadata payload:', metadataError);
            normalizedMetadata = null;
        }
    }

    const payload = {
        html: trimmedHtml,
        waitTime,
        includeImages,
        includeLinks,
        includeMetadata,
        cleanContent,
        blockMedia,
        metadata: normalizedMetadata,
        cached: false
    };

    playwrightRenderCache.set(cacheKey, { timestamp: Date.now(), payload });
    if (playwrightRenderCache.size > PLAYWRIGHT_CACHE_LIMIT) {
        const oldestKey = playwrightRenderCache.keys().next().value;
        if (oldestKey) {
            playwrightRenderCache.delete(oldestKey);
        }
    }

    return payload;
}

async function runPlaywrightExtractionTool(args = {}) {
    const parsed = typeof args === 'object' && args !== null ? args : {};
    const rawUrl = typeof parsed.url === 'string' ? parsed.url : parsed.href;
    const targetUrlInput = String(rawUrl || '').trim();
    const queryInput = typeof parsed.query === 'string' ? parsed.query.trim() : '';
    const providerKeyInput = typeof parsed.search_provider === 'string'
        ? parsed.search_provider.trim().toLowerCase()
        : '';
    const searchProvider = getSearchProviderConfig(providerKeyInput);

    let targetUrl = targetUrlInput;
    let derivedFromQuery = false;

    if (queryInput) {
        const providerUrl = searchProvider.buildUrl(queryInput);
        const providerHost = getHostname(providerUrl);
        const targetHostInput = targetUrl ? getHostname(targetUrl) : '';
        if (!targetUrl || targetHostInput === providerHost) {
            if (!targetUrl) {
                targetUrl = providerUrl;
            }
            derivedFromQuery = true;
        }
    }

    if (!targetUrl) {
        const payload = { error: 'Provide either "url" or "query" when calling render_with_playwright.', receivedArguments: parsed };
        return {
            name: 'render_with_playwright',
            content: JSON.stringify(payload),
            display: 'Error: missing url or query',
            arguments: parsed,
            error: true
        };
    }

    try {
        let rawTargetHost = '';
        try {
            rawTargetHost = new URL(targetUrl).hostname || targetUrl;
        } catch {
            rawTargetHost = targetUrl;
        }
        const targetHost = getHostname(targetUrl);
        const primaryHost = getPrimaryExtractionHostname();
        const guardHost = primaryHost && !isAllowedSecondaryHost(primaryHost) ? primaryHost : '';
        const allowCrossOrigin =
            derivedFromQuery ||
            isAllowedSecondaryHost(targetHost);
        if (guardHost && targetHost && targetHost !== guardHost && !allowCrossOrigin) {
            const payload = {
                error: `Playwright helper is restricted to ${guardHost}. Received url for ${targetHost || 'unknown host'}.`,
                receivedArguments: parsed
            };
            return {
                name: 'render_with_playwright',
                content: JSON.stringify(payload),
                display: `Error: cross-origin render blocked (${guardHost} expected, got ${rawTargetHost || 'unknown host'})`,
                arguments: parsed,
                error: true
            };
        }

        let renderPayload = await requestPlaywrightHtml(targetUrl, parsed);

        const needsFullRefresh =
            renderPayload?.cached &&
            isLikelyFallbackHtml(renderPayload.html, targetHost);

        if (needsFullRefresh) {
            try {
                const refreshOverrides = {
                    ...parsed,
                    use_cache: false
                };
                if (coerceBoolean(getOverrideValue(parsed, ['block_media', 'blockMedia']), renderPayload.blockMedia)) {
                    refreshOverrides.block_media = false;
                }
                renderPayload = await requestPlaywrightHtml(targetUrl, refreshOverrides);
                renderPayload.forcedRefresh = true;
            } catch (refreshError) {
                console.warn('Playwright full refresh failed, continuing with cached content:', refreshError);
            }
        }

        const {
            html,
            waitTime,
            includeImages,
            includeLinks,
            includeMetadata,
            cleanContent,
            blockMedia,
            cached,
            forcedRefresh = false
        } = renderPayload;

        const parser = new DOMParser();
        const doc = parser.parseFromString(html || '', 'text/html');
        const extraction = {
            url: targetUrl,
            timestamp: new Date().toISOString(),
            metadata: extractMetadata(doc),
            content: extractMainContent(doc),
            links: extractLinks(doc),
            images: extractImages(doc),
            structure: extractStructure(doc),
            extractionMethod: 'playwright-tool'
        };

        if (renderPayload.metadata && typeof renderPayload.metadata === 'object') {
            const mergedMetadata = { ...(extraction.metadata || {}) };
            Object.entries(renderPayload.metadata).forEach(([key, value]) => {
                if (value === null || value === undefined || value === '') {
                    return;
                }
                if (typeof value === 'object' && !Array.isArray(value)) {
                    mergedMetadata[key] = {
                        ...(value || {}),
                        ...(mergedMetadata[key] || {})
                    };
                } else if (!mergedMetadata[key]) {
                    mergedMetadata[key] = value;
                }
            });
            mergedMetadata.playwright = {
                ...(mergedMetadata.playwright || {}),
                ...renderPayload.metadata
            };
            extraction.metadata = mergedMetadata;

            const metadataSummaryLines = [];
            if (renderPayload.metadata.title) {
                metadataSummaryLines.push(`Title: ${renderPayload.metadata.title}`);
            }
            if (renderPayload.metadata.channel) {
                metadataSummaryLines.push(`Channel: ${renderPayload.metadata.channel}`);
            }
            if (renderPayload.metadata.published) {
                metadataSummaryLines.push(`Published: ${renderPayload.metadata.published}`);
            }
            if (renderPayload.metadata.viewCount) {
                metadataSummaryLines.push(`Views: ${renderPayload.metadata.viewCount}`);
            }
            if (renderPayload.metadata.duration) {
                metadataSummaryLines.push(`Duration: ${renderPayload.metadata.duration}`);
            }
            if (renderPayload.metadata.keywords) {
                metadataSummaryLines.push(`Keywords: ${renderPayload.metadata.keywords}`);
            }
            if (renderPayload.metadata.description) {
                metadataSummaryLines.push('');
                metadataSummaryLines.push(renderPayload.metadata.description);
            }
            const metadataSummary = metadataSummaryLines.join('\n').trim();
            if (metadataSummary && !/Playwright Captured Video Summary:/i.test(extraction.content || '')) {
                const injectedBlock = `Playwright Captured Video Summary:\n${metadataSummary}`;
                extraction.content = extraction.content
                    ? `${injectedBlock}\n\n${extraction.content}`
                    : injectedBlock;
            }
        }

        extraction.links = Array.isArray(extraction.links) ? extraction.links.slice(0, 50) : [];
        extraction.images = Array.isArray(extraction.images) ? extraction.images.slice(0, 30) : [];

        const formatted = formatForLLM(extraction);
        const markdown = convertToMarkdown(extraction);

        const MAX_HTML_LENGTH = 120000;
        const truncated = (html || '').length > MAX_HTML_LENGTH;
        const trimmedHtml = truncated ? `${html.slice(0, MAX_HTML_LENGTH)}<!-- Truncated -->` : html;

        const options = {
            include_images: includeImages,
            include_links: includeLinks,
            include_metadata: includeMetadata,
            clean_content: cleanContent,
            block_media: blockMedia
        };
        if (derivedFromQuery) {
            options.search_provider = searchProvider.key;
        }

        const payload = {
            success: true,
            url: targetUrl,
            fetched_at: extraction.timestamp,
            wait_time: waitTime,
            options,
            html: trimmedHtml,
            html_truncated: truncated,
            html_length: (html || '').length,
            summary: formatted,
            markdown,
            metadata: extraction.metadata,
            structure: extraction.structure,
            links: extraction.links,
            images: extraction.images,
            extraction_method: extraction.extractionMethod,
            cached: Boolean(cached)
        };

        payload.force_refreshed = Boolean(forcedRefresh);

        if (derivedFromQuery) {
            payload.search_query = queryInput;
            payload.search_provider = searchProvider.key;
        }

        const statusLabel = forcedRefresh ? 'Refreshed' : cached ? 'Cached' : 'Rendered';
        const display = derivedFromQuery
            ? `${statusLabel} ${searchProvider.label} for “${truncateText(queryInput, 60)}” (${(html || '').length.toLocaleString()} chars)`
            : `${statusLabel} ${truncateText(targetUrl, 60)} (${(html || '').length.toLocaleString()} chars)`;

        return {
            name: 'render_with_playwright',
            content: JSON.stringify(payload),
            display,
            arguments: parsed,
            cached: Boolean(cached),
            forceRefreshed: Boolean(forcedRefresh),
            searchQuery: derivedFromQuery ? queryInput : undefined,
            searchProvider: derivedFromQuery ? searchProvider.key : undefined
        };
    } catch (error) {
        console.error('Playwright tool execution failed:', error);
        const payload = {
            error: error?.message || 'Playwright tool failed.',
            url: targetUrl,
            receivedArguments: parsed
        };
        if (queryInput) {
            payload.search_query = queryInput;
        }
        if (derivedFromQuery) {
            payload.search_provider = searchProvider.key;
        }
        return {
            name: 'render_with_playwright',
            content: JSON.stringify(payload),
            display: `Error: ${error?.message || 'Playwright tool failed.'}`,
            arguments: parsed,
            error: true
        };
    }
}

function parseToolArguments(rawArgs) {
    if (!rawArgs) {
        return {};
    }
    if (typeof rawArgs === 'object') {
        return rawArgs;
    }
    try {
        return JSON.parse(rawArgs);
    } catch (error) {
        console.warn('Unable to parse tool arguments:', rawArgs, error);
        return { _parse_error: 'Invalid JSON arguments', raw: String(rawArgs) };
    }
}

function stableStringify(value) {
    if (value === undefined) {
        return 'undefined';
    }
    if (value === null || typeof value !== 'object') {
        return JSON.stringify(value);
    }
    if (Array.isArray(value)) {
        return `[${value.map(item => stableStringify(item)).join(',')}]`;
    }
    const keys = Object.keys(value).sort();
    const parts = keys.map(key => `${JSON.stringify(key)}:${stableStringify(value[key])}`);
    return `{${parts.join(',')}}`;
}

function buildToolSignature(toolCall) {
    const name = toolCall?.function?.name || toolCall?.name || 'unknown_tool';
    let parsedArgs = {};
    try {
        parsedArgs = parseToolArguments(toolCall?.function?.arguments ?? toolCall?.arguments ?? {});
    } catch (error) {
        console.warn('Unable to normalise tool arguments for signature generation:', error);
    }
    return `${name}::${stableStringify(parsedArgs)}`;
}

function canonicalizeHostname(hostname) {
    if (!hostname) {
        return '';
    }
    const normalized = hostname.toLowerCase();
    const stripped = normalized.replace(/^www\./, '');
    return PLAYWRIGHT_HOST_CANONICAL_MAP[stripped] || stripped;
}

function getHostname(value) {
    try {
        const parsed = new URL(String(value));
        return canonicalizeHostname(parsed.hostname);
    } catch {
        return '';
    }
}

function getPrimaryExtractionHostname() {
    if (extractedData?.url) {
        const host = getHostname(extractedData.url);
        if (host) {
            return host;
        }
    }
    const lastRecord = extractionHistory.length ? extractionHistory[extractionHistory.length - 1] : null;
    if (lastRecord?.url) {
        const host = getHostname(lastRecord.url);
        if (host) {
            return host;
        }
    }
    return '';
}

function getSearchProviderConfig(providerKey) {
    const normalized = (providerKey || '').toString().trim().toLowerCase();
    return PLAYWRIGHT_SEARCH_PROVIDERS[normalized] || PLAYWRIGHT_SEARCH_PROVIDERS[PLAYWRIGHT_DEFAULT_SEARCH_PROVIDER];
}

function buildSearchProviderUrl(query, providerKey = PLAYWRIGHT_DEFAULT_SEARCH_PROVIDER) {
    const provider = getSearchProviderConfig(providerKey);
    return provider.buildUrl(query || '');
}

function isAllowedSecondaryHost(hostname) {
    if (!hostname) {
        return false;
    }
    return PLAYWRIGHT_ALLOWED_SECONDARY_HOSTS.has(hostname);
}

function runGetCurrentTimeTool(args = {}) {
    const parsed = typeof args === 'object' && args !== null ? args : {};
    const now = new Date();
    const iso = now.toISOString();
    const locale = now.toLocaleString();
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
    const requestedFormat = typeof parsed.format === 'string' ? parsed.format.toLowerCase() : 'iso';
    const primary =
        requestedFormat === 'locale' || requestedFormat === 'local'
            ? locale
            : iso;

    const payload = {
        current_time: primary,
        iso,
        locale,
        timezone,
        format_used: requestedFormat === 'locale' || requestedFormat === 'local' ? 'locale' : 'iso'
    };

    return {
        name: 'get_current_time',
        content: JSON.stringify(payload),
        display: `${primary} (${timezone})`,
        arguments: parsed
    };
}

async function executeOllamaToolCall(toolCall) {
    const fn = toolCall?.function || {};
    const name = fn.name || toolCall?.name || 'unknown_tool';
    const args = parseToolArguments(fn.arguments ?? toolCall?.arguments ?? {});

    switch (name) {
        case 'get_current_time':
            return runGetCurrentTimeTool(args);
        case 'render_with_playwright':
            return await runPlaywrightExtractionTool(args);
        default:
            const errorPayload = {
                error: `Tool "${name}" is not implemented.`,
                receivedArguments: args
            };
            return {
                name,
                content: JSON.stringify(errorPayload),
                display: 'Unsupported tool call',
                arguments: args,
                error: true
            };
    }
}

function normalizeModelOutput(text) {
    if (typeof text !== 'string') {
        return text;
    }
    let normalized = stripPlaceholderTokens(text);
    normalized = normalized.replace(/[ \t]+\n/g, '\n').replace(/\n{3,}/g, '\n\n');
    return normalized.trim();
}

function truncateText(value, limit = 80) {
    const text = String(value);
    return text.length > limit ? `${text.slice(0, limit - 1)}…` : text;
}

function extractJsonCandidate(raw) {
    raw = normalizeModelOutput(raw);
    if (!raw) return null;
    const codeMatch = raw.match(/```json\s*([\s\S]+?)```/i);
    if (codeMatch) {
        return codeMatch[1].trim();
    }
    const firstBrace = raw.indexOf('{');
    const lastBrace = raw.lastIndexOf('}');
    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        return raw.slice(firstBrace, lastBrace + 1);
    }
    return null;
}

function parseInstructionDecision(raw) {
    const candidate = extractJsonCandidate(raw?.trim() || '');
    if (!candidate) {
        return null;
    }
    try {
        const data = JSON.parse(candidate);
        if (!data || typeof data !== 'object') {
            return null;
        }
        const decision = typeof data.decision === 'string'
            ? data.decision.trim().toLowerCase()
            : '';
        if (!decision || !['answer', 'search'].includes(decision)) {
            return null;
        }
        const normalizeList = (value) => Array.isArray(value)
            ? value.map(item => String(item || '').trim()).filter(Boolean)
            : [];
        return {
            decision,
            reason: typeof data.reason === 'string' ? normalizeModelOutput(data.reason) : '',
            answer: typeof data.answer === 'string' ? normalizeModelOutput(data.answer) : '',
            searchQueries: normalizeList(data.search_queries || data.queries).map(normalizeModelOutput),
            suggestedUrls: normalizeList(data.suggested_urls || data.urls).map(normalizeModelOutput)
        };
    } catch (error) {
        console.warn('Unable to parse decision JSON:', error);
        return null;
    }
}

function renderInstructionDecision(decisionData) {
    if (!decisionData) {
        return null;
    }

    const parts = [];
    if (decisionData.reason) {
        parts.push(`<div class="assistant-llm-reason">${convertMarkdownToHtml(decisionData.reason)}</div>`);
    }

    if (decisionData.decision === 'answer') {
        const answer = decisionData.answer || '(No answer returned.)';
        parts.push(convertMarkdownToHtml(answer));
        return cleanPlaceholderArtifacts(parts.join('\n'));
    }

    const listItems = [];
    decisionData.searchQueries.forEach(query => {
        listItems.push(`<li>${escapeHtml(query)}</li>`);
    });
    decisionData.suggestedUrls.forEach(url => {
        listItems.push(`<li>${escapeHtml(url)}</li>`);
    });
    if (listItems.length) {
        parts.push(`<ul class="assistant-search-list">${listItems.join('')}</ul>`);
    }

    const actionButtons = [];
    decisionData.searchQueries.forEach(query => {
        actionButtons.push(`
            <button type="button" class="assistant-search-button" data-search-query="${escapeAttribute(query)}" data-search-provider="google">
                🔍 Google “${escapeHtml(truncateText(query, 60))}”
            </button>
        `);
    });
    decisionData.suggestedUrls.forEach(url => {
        actionButtons.push(`
            <button type="button" class="assistant-search-button" data-search-url="${escapeAttribute(url)}">
                🌐 Open ${escapeHtml(truncateText(url, 40))}
            </button>
        `);
    });

    if (actionButtons.length) {
        parts.push(`<div class="assistant-search-actions">${actionButtons.join('')}</div>`);
        if (decisionData.searchQueries.length) {
            parts.push('<p class="assistant-search-note">Search buttons use Google by default. Ask for another provider if you prefer a different engine.</p>');
        }
    } else {
        parts.push('<p>No actionable search queries were provided.</p>');
    }

    return cleanPlaceholderArtifacts(parts.join('\n'));
}

function renderExtractionDetails(data, extractionIndex) {
    if (!data) {
        return '';
    }

    const detailId = `details-${Date.now().toString(36)}-${Math.floor(Math.random() * 1e6)}`;
    const formattedOutline = escapeHtml((formatForLLM(data) || '').trim());
    const structuredJson = escapeHtml(JSON.stringify(data.structure ?? {}, null, 2));
    const markdown = escapeHtml((convertToMarkdown(data) || '').trim());
    const rawJson = escapeHtml(JSON.stringify(data, null, 2));
    const methodLabel = data.extractionMethod ? `<div class="assistant-extraction-meta">Method: ${escapeHtml(data.extractionMethod)}</div>` : '';
    const indexAttr = typeof extractionIndex === 'number' ? ` data-extraction-index="${extractionIndex}"` : '';

    return `
        <div class="assistant-extraction"${indexAttr}>
            <div class="assistant-extraction-header">
                ${methodLabel}
                <button class="assistant-extraction-toggle" type="button" data-target="${detailId}">
                    <span>Extraction Details</span>
                    <span class="assistant-extraction-icon">▸</span>
                </button>
            </div>
            <div class="assistant-extraction-body" id="${detailId}">
                <div class="assistant-tabs" role="tablist">
                    <button type="button" class="assistant-tab-button active" data-tab="outline">Formatted Text</button>
                    <button type="button" class="assistant-tab-button" data-tab="structured">Structured Data</button>
                    <button type="button" class="assistant-tab-button" data-tab="markdown">Markdown</button>
                    <button type="button" class="assistant-tab-button" data-tab="json">Full JSON</button>
                </div>
                <div class="assistant-tab-content active" data-tab="outline">
                    <div class="assistant-preview-header">
                        <button type="button" class="assistant-download-button tertiary" data-copy-format="outline" data-copy-label="Formatted Text">
                            📋 Copy
                        </button>
                    </div>
                    <pre class="assistant-content-preview">${formattedOutline}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="structured">
                    <pre class="assistant-content-preview">${structuredJson}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="markdown">
                    <pre class="assistant-content-preview">${markdown}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="json">
                    <pre class="assistant-content-preview">${rawJson}</pre>
                </div>
                <div class="assistant-downloads">
                    <button type="button" class="assistant-download-button copy-main" data-copy-format="main">
                        📋 Copy Main Content
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="txt">
                        📄 Copy Text
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="md">
                        📝 Copy Markdown
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="json">
                        📊 Copy JSON
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="html">
                        🌐 Copy HTML
                    </button>
                </div>
            </div>
        </div>
    `;
}

function sanitizePreformattedHtml(value) {
    value = normalizeModelOutput(value);
    return value
        .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '')
        .replace(/\son\w+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s>]+)/gi, '')
        .replace(/\shref\s*=\s*(?:"\s*javascript:[^"]*"|'\s*javascript:[^']*'|javascript:[^\s>]*)/gi, ' href="#"')
        .replace(/\ssrc\s*=\s*(?:"\s*javascript:[^"]*"|'\s*javascript:[^']*'|javascript:[^\s>]*)/gi, '')
        .replace(/<\/?(?:iframe|embed|object|link|meta)[\s\S]*?>/gi, '');
}

function sanitizeLinkUrl(url) {
    const trimmed = url.trim();
    if (/^(https?:|mailto:|tel:)/i.test(trimmed)) {
        return trimmed;
    }
    return '';
}

function applyInlineFormatting(text) {
    const replacements = [];
    let working = text;

    const registerReplacement = (html, label) => {
        const token = `@@__${label}_${replacements.length}__@@`;
        replacements.push({ token, html });
        return token;
    };

    working = working.replace(/`([^`]+)`/g, (_, code) => registerReplacement(`<code>${escapeHtml(code)}</code>`, 'CODE'));

    working = working.replace(/\*\*([^*]+)\*\*/g, (_, content) => registerReplacement(`<strong>${escapeHtml(content)}</strong>`, 'BOLD'));
    working = working.replace(/__([^_]+)__/g, (_, content) => registerReplacement(`<strong>${escapeHtml(content)}</strong>`, 'BOLD'));

    working = working.replace(/~~([^~]+)~~/g, (_, content) => registerReplacement(`<del>${escapeHtml(content)}</del>`, 'DEL'));

    working = working.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, url) => {
        const safeUrl = sanitizeLinkUrl(url);
        if (!safeUrl) {
            return registerReplacement(escapeHtml(`[${label}](${url})`), 'TEXT');
        }
        return registerReplacement(
            `<a href="${escapeAttribute(safeUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(label)}</a>`,
            'LINK'
        );
    });

    working = working.replace(/\*([^*]+)\*/g, (_, content) => registerReplacement(`<em>${escapeHtml(content)}</em>`, 'EM'));
    working = working.replace(/_([^_]+)_/g, (_, content) => registerReplacement(`<em>${escapeHtml(content)}</em>`, 'EM'));

    let escaped = escapeHtml(working);
    for (const { token, html } of replacements) {
        escaped = escaped.split(token).join(html);
    }
    return escaped;
}

function convertMarkdownToHtml(markdown) {
    const lines = markdown.replace(/\r\n/g, '\n').split('\n');
    const html = [];
    let inUl = false;
    let inOl = false;
    let inCode = false;
    let codeLang = '';
    let codeLines = [];
    let paragraphLines = [];

    const closeLists = () => {
        if (inUl) {
            html.push('</ul>');
            inUl = false;
        }
        if (inOl) {
            html.push('</ol>');
            inOl = false;
        }
    };

    const flushParagraph = () => {
        if (!paragraphLines.length) {
            return;
        }
        const content = paragraphLines.join('\n');
        const formatted = applyInlineFormatting(content).replace(/\n/g, '<br>');
        html.push(`<p>${formatted}</p>`);
        paragraphLines = [];
    };

    const flushCodeBlock = () => {
        if (!inCode) {
            return;
        }
        const codeContent = codeLines.join('\n');
        const langAttr = codeLang ? ` class="language-${escapeHtml(codeLang)}"` : '';
        html.push(`<pre><code${langAttr}>${escapeHtml(codeContent)}</code></pre>`);
        inCode = false;
        codeLang = '';
        codeLines = [];
    };

    for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, '    ');
        const trimmed = line.trim();

        if (inCode) {
            if (/^```/.test(trimmed)) {
                flushCodeBlock();
            } else {
                codeLines.push(line);
            }
            continue;
        }

        if (!trimmed) {
            flushParagraph();
            closeLists();
            continue;
        }

        const codeStart = trimmed.match(/^```(\w+)?/);
        if (codeStart) {
            flushParagraph();
            closeLists();
            inCode = true;
            codeLang = codeStart[1] || '';
            continue;
        }

        const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
        if (headingMatch) {
            flushParagraph();
            closeLists();
            const level = headingMatch[1].length;
            html.push(`<h${level}>${applyInlineFormatting(headingMatch[2])}</h${level}>`);
            continue;
        }

        if (/^>\s?/.test(trimmed)) {
            flushParagraph();
            closeLists();
            const quote = trimmed.replace(/^>\s?/, '');
            html.push(`<blockquote>${applyInlineFormatting(quote)}</blockquote>`);
            continue;
        }

        if (/^([-*_])\s*\1\s*\1\s*$/.test(trimmed)) {
            flushParagraph();
            closeLists();
            html.push('<hr>');
            continue;
        }

        const olMatch = trimmed.match(/^(\d+)[.)]\s+(.*)$/);
        if (olMatch) {
            flushParagraph();
            if (!inOl) {
                closeLists();
                html.push('<ol>');
                inOl = true;
            }
            html.push(`<li>${applyInlineFormatting(olMatch[2])}</li>`);
            continue;
        }

        const ulMatch = trimmed.match(/^[-*+]\s+(.*)$/);
        if (ulMatch) {
            flushParagraph();
            if (!inUl) {
                closeLists();
                html.push('<ul>');
                inUl = true;
            }
            html.push(`<li>${applyInlineFormatting(ulMatch[1])}</li>`);
            continue;
        }

        paragraphLines.push(line);
    }

    flushParagraph();
    flushCodeBlock();
    closeLists();

    if (!html.length) {
        return `<p>${escapeHtml(markdown)}</p>`;
    }

    return html.join('');
}

function renderLlmOutput(message) {
    if (typeof message !== 'string') {
        return '<em>(Unexpected LLM response format.)</em>';
    }

    const trimmed = normalizeModelOutput(message);
    if (!trimmed) {
        return '<em>(LLM returned an empty response.)</em>';
    }

    const sanitized = sanitizePreformattedHtml(trimmed);
    if (/<\/?[a-z][\s\S]*>/i.test(sanitized)) {
        return cleanPlaceholderArtifacts(normalizeModelOutput(sanitized));
    }

    return cleanPlaceholderArtifacts(normalizeModelOutput(convertMarkdownToHtml(sanitized))); 
}

function scrollConversationToEnd() {
    if (conversationEl) {
        conversationEl.scrollTop = conversationEl.scrollHeight;
    }
}

(function restorePlaywrightServerSetting() {
    playwrightServerInput = document.getElementById('playwrightServer');
    if (!playwrightServerInput) return;
    if (!playwrightServerInput.dataset.defaultPlaceholder) {
        playwrightServerInput.dataset.defaultPlaceholder = playwrightServerInput.getAttribute('placeholder') || 'http://localhost:3050';
    }
    try {
        const saved = localStorage.getItem(PLAYWRIGHT_STORAGE_KEY);
        if (saved) {
            playwrightServerInput.value = saved;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Playwright server URL:', storageError);
    }
    playwrightServerInput.addEventListener('change', () => {
        try {
            localStorage.setItem(PLAYWRIGHT_STORAGE_KEY, playwrightServerInput.value.trim());
        } catch (storageError) {
            console.warn('Unable to persist Playwright server URL:', storageError);
        }
        playwrightRenderCache.clear();
    });
})();
initializePlaywrightMode();

(function watchPlaywrightOptionChanges() {
    const blockToggle = document.getElementById('blockMedia');
    if (blockToggle) {
        blockToggle.addEventListener('change', () => {
            playwrightRenderCache.clear();
        });
    }
})();

(function restoreOllamaSettings() {
    const serverInput = document.getElementById('ollamaServer');
    const modelSelect = document.getElementById('ollamaModel');
    if (!serverInput || !modelSelect) return;

    let storedServerUrl = 'http://localhost:11434';
    try {
        const saved = localStorage.getItem(OLLAMA_SERVER_STORAGE_KEY);
        if (saved) {
            storedServerUrl = saved;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Ollama server URL:', storageError);
    }
    serverInput.value = normalizeOllamaBaseUrl(storedServerUrl);

    serverInput.addEventListener('change', () => {
        const normalized = normalizeOllamaBaseUrl(serverInput.value);
        serverInput.value = normalized;
        try {
            localStorage.setItem(OLLAMA_SERVER_STORAGE_KEY, normalized);
        } catch (storageError) {
            console.warn('Unable to persist Ollama server URL:', storageError);
        }
        loadOllamaModels(true);
    });

    try {
        const savedModel = localStorage.getItem(OLLAMA_MODEL_STORAGE_KEY);
        if (savedModel) {
            modelSelect.dataset.preferredModel = savedModel;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Ollama model preference:', storageError);
    }

    loadOllamaModels();

    modelSelect.addEventListener('change', () => {
        try {
            localStorage.setItem(OLLAMA_MODEL_STORAGE_KEY, modelSelect.value);
        } catch (storageError) {
            console.warn('Unable to persist Ollama model preference:', storageError);
        }
        updateLlmSendAvailability();
    });
})();

(function setupOptionsToggle() {
    const toggle = document.getElementById('optionsToggle');
    const content = document.getElementById('optionsToggleContent');
    const icon = document.getElementById('optionsToggleIcon');
    const panel = document.getElementById('optionsPanel');
    if (!toggle || !content || !icon || !panel) {
        return;
    }

    function applyState(collapsed) {
        content.classList.toggle('collapsed', collapsed);
        toggle.classList.toggle('collapsed', collapsed);
        panel.classList.toggle('collapsed', collapsed);
        icon.textContent = collapsed ? '▸' : '▾';
    }

    applyState(true);

    toggle.addEventListener('click', () => {
        applyState(!content.classList.contains('collapsed'));
    });
})();

if (conversationEl) {
    conversationEl.addEventListener('click', event => {
        const bubbleCopyButton = event.target.closest('[data-copy]');
        if (bubbleCopyButton) {
            const targetType = bubbleCopyButton.dataset.copy;
            const bubble = bubbleCopyButton.closest('.conversation-bubble');
            if (!bubble) {
                return;
            }
            if (targetType === 'assistant') {
                copyLlmResponse(bubble);
            } else if (targetType === 'user') {
                copyUserMessage(bubble);
            }
            return;
        }

        const toggleButton = event.target.closest('.assistant-extraction-toggle');
        if (toggleButton) {
            const container = toggleButton.closest('.assistant-extraction');
            if (container) {
                const isOpen = container.classList.toggle('open');
                const icon = toggleButton.querySelector('.assistant-extraction-icon');
                if (icon) {
                    icon.textContent = isOpen ? '▾' : '▸';
                }
            }
            return;
        }

        const tabButton = event.target.closest('.assistant-tab-button');
        if (tabButton) {
            const body = tabButton.closest('.assistant-extraction-body');
            if (!body) {
                return;
            }
            const tabName = tabButton.dataset.tab;
            body.querySelectorAll('.assistant-tab-button').forEach(btn => btn.classList.remove('active'));
            tabButton.classList.add('active');
            body.querySelectorAll('.assistant-tab-content').forEach(panel => {
                panel.classList.toggle('active', panel.dataset.tab === tabName);
            });
            return;
        }

        const searchActionButton = event.target.closest('.assistant-search-button');
        if (searchActionButton) {
            executeSearchRecommendation(searchActionButton).catch(error => {
                console.error('Search recommendation execution failed:', error);
                showError(`Search failed: ${error.message}`);
            });
            return;
        }

        const copyButton = event.target.closest('.assistant-download-button');
        if (copyButton) {
            const container = copyButton.closest('.assistant-extraction');
            let format = copyButton.dataset.copyFormat;
            if (format === 'outline') {
                format = 'txt';
            }
            const index = container && container.dataset.extractionIndex !== undefined
                ? Number(container.dataset.extractionIndex)
                : undefined;
            copyExtractionContent(format, Number.isFinite(index) ? index : undefined);
        }
    });
}

const taskInputElement = document.getElementById('taskInput');
if (taskInputElement) {
    taskInputElement.addEventListener('keydown', event => {
        if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            runTask();
        }
    });
}

function extractFirstUrl(text) {
    if (!text) return null;
    const match = text.match(/https?:\/\/[^\s"'<>]+/i);
    if (!match) return null;
    return match[0].replace(/["')\],.?!]+$/, '');
}

async function runTask() {
    const instruction = (taskInputElement?.value || '').trim();
    if (!instruction) {
        showError('Please enter an instruction.');
        return;
    }

    const targetUrl = extractFirstUrl(instruction);
    if (targetUrl && !isValidUrl(targetUrl)) {
        showError('The URL detected in your instruction is not valid. Please double-check it.');
        return;
    }

    appendConversationMessage('user', renderUserMessage(instruction));
    if (taskInputElement) {
        taskInputElement.value = '';
    }

    hideMessages();

    if (!targetUrl) {
        pendingAssistantMessage = appendConversationMessage('assistant', renderAssistantLoading('Consulting LLM...'));
        try {
            await handleInstructionWithoutUrl(instruction, pendingAssistantMessage);
        } catch (error) {
            const message = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
            updateConversationMessage(pendingAssistantMessage, message);
            showError(`Unable to process the instruction: ${error.message}`);
        } finally {
            pendingAssistantMessage = null;
        }
        return;
    }

    pendingAssistantMessage = appendConversationMessage('assistant', renderAssistantLoading('Extracting page content...'));

    extractedData = null;
    updateLlmSendAvailability();

    showProgress();
    setProgress(0, 'Preparing to extract content...');

    try {
        const content = await extractContent(targetUrl);
        const record = { ...content, instruction };
        const extractionIndex = extractionHistory.push(record) - 1;
        record.extractionIndex = extractionIndex;
        extractedData = record;
        updateLlmSendAvailability();
        storeExtractionRecord(record);

        const methodElement = document.getElementById('extractionMethod');
        if (methodElement) {
            methodElement.style.display = 'none';
        }

        setProgress(100, 'Extraction complete!');
        hideProgress();
        showSuccess('Content extracted successfully!');

        if (pendingAssistantMessage) {
            updateConversationMessage(pendingAssistantMessage, renderAssistantLoading('Generating LLM response...'));
        }

        const modelSelect = document.getElementById('ollamaModel');
        if (modelSelect && modelSelect.value) {
            setLlmStatus('info', 'Generating response with your Ollama model...');
            await sendToLLM(true, pendingAssistantMessage, extractionIndex);
        } else {
            const placeholder = '<p>Extraction complete. Choose an Ollama model under Settings, then click “Send to Ollama”.</p>';
            updateConversationMessage(pendingAssistantMessage, renderAssistantResponse(placeholder, record, extractionIndex));
            setLlmStatus('warning', 'Extraction ready. Choose an Ollama model and click “Send to Ollama” to continue.');
        }
    } catch (error) {
        setProgress(0, 'Error occurred');
        hideProgress();
        const message = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(pendingAssistantMessage, message);
        showError(`Failed to complete the task: ${error.message}`);
    } finally {
        pendingAssistantMessage = null;
    }
}

async function handleInstructionWithoutUrl(instruction, messageEl) {
    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect || !modelSelect.value) {
        const placeholder = '<p>No URL detected. Choose an Ollama model under Settings to get a direct answer, or provide a URL for extraction.</p>';
        updateConversationMessage(messageEl, renderAssistantResponse(placeholder, null));
        showWarning('Select an Ollama model to answer instructions without URLs.');
        setLlmStatus('warning', 'Select an Ollama model to answer instructions without URLs.');
        return;
    }

    const sendButton = document.getElementById('llmSendButton');
    if (sendButton) {
        sendButton.disabled = true;
    }

    showLlmProgress('Preparing LLM request...', 10);
    setLlmStatus('info', `Sending instruction to ${modelSelect.value}...`);

    let baseUrl = 'http://localhost:11434';
    try {
        baseUrl = getOllamaBaseUrl();
    } catch (error) {
        hideLlmProgress();
        setLlmStatus('error', error.message);
        const errorHtml = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(messageEl, renderAssistantResponse(errorHtml, null));
        if (sendButton) {
            sendButton.disabled = !(extractedData && modelSelect.value);
        }
        return;
    }

    const decisionPrompt = [
        'You are an assistant embedded in a web content extraction tool.',
        'The user provided an instruction with no URLs.',
        'Return ONLY a JSON object (no extra text) using this schema:',
        '{',
        '  "decision": "answer" | "search",',
        '  "reason": "Why you chose this path.",',
        '  "answer": "Direct Markdown-formatted reply (required when decision is \\"answer\\").",',
        '  "search_queries": ["Suggested search phrases..."],',
        '  "suggested_urls": ["Optional direct URLs to visit."]',
        '}',
        'When decision == "answer", include a concise, current answer in the "answer" field.',
        'When recommending searches, favour queries that can be executed on Google Search (https://www.google.com) unless the user explicitly requests another provider.',
        'When decision == "search", provide at least one search query or URL in the appropriate arrays.',
        'Use standard Markdown in strings; avoid placeholder tokens like @@ or XML.'
    ].join('\n');

    const assembledPrompt = `${decisionPrompt}

User instruction:
${instruction}`;

    try {
        updateLlmProgress(35, `Sending request to ${baseUrl}...`);
        const response = await fetch(`${baseUrl}/api/generate`, {
            method: 'POST',
            mode: 'cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: modelSelect.value,
                prompt: assembledPrompt,
                stream: false
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(formatOllamaError(response.status, errorText));
        }

        updateLlmProgress(70, 'Waiting for LLM response...');
        const result = await response.json();
        const message = result?.response || result?.message || '(No response text received.)';
        updateLlmProgress(100, 'LLM response received.');

        const decisionData = parseInstructionDecision(message);
        if (decisionData) {
            if (decisionData.decision === 'search') {
                const decisionHtml = renderInstructionDecision(decisionData) || renderLlmOutput(message);
                updateConversationMessage(
                    messageEl,
                    renderAssistantResponse(decisionHtml, null)
                );
                setLlmStatus('info', 'Search recommended. Use the suggested actions to continue.');
            } else {
                await generateInstructionAnswer(instruction, messageEl, decisionData);
            }
        } else {
            const llmHtml = renderLlmOutput(message);
            updateConversationMessage(
                messageEl,
                renderAssistantResponse(llmHtml, null)
            );
            setLlmStatus('success', `Response generated with ${modelSelect.value}.`);
        }
    } catch (error) {
        console.error('Instruction-only LLM request failed:', error);
        updateLlmProgress(0, 'LLM request failed.');
        let errorMessage = error?.message || 'Failed to reach Ollama.';
        if (error instanceof TypeError || /Failed to fetch/i.test(errorMessage)) {
            const currentOrigin = window.location.origin || 'file://';
            errorMessage = [
                'Browser blocked the request to Ollama (likely CORS).',
                'Restart Ollama with CORS enabled, for example:',
                '  export OLLAMA_ORIGINS="*"',
                '  ollama serve',
                `or allow the UI origin explicitly: OLLAMA_ORIGINS="${currentOrigin}"`,
                `Attempted endpoint: ${baseUrl}/api/chat`
            ].join('\n');
        }
        setLlmStatus('error', errorMessage);
        const errorHtml = `<div class="assistant-error">${escapeHtml(errorMessage)}</div>`;
        updateConversationMessage(
            messageEl,
            renderAssistantResponse(errorHtml, null)
        );
        showError(`LLM request failed: ${errorMessage}`);
    } finally {
        setTimeout(() => hideLlmProgress(), 1500);
        if (sendButton) {
            sendButton.disabled = !(extractedData && modelSelect && modelSelect.value);
        }
        updateLlmSendAvailability();
    }
}

function buildSearchUrl(query, providerKey = PLAYWRIGHT_DEFAULT_SEARCH_PROVIDER) {
    if (!query) {
        return '';
    }
    return buildSearchProviderUrl(query, providerKey);
}

async function executeSearchRecommendation(button) {
    if (!button) {
        return;
    }

    const query = (button.dataset.searchQuery || '').trim();
    const directUrl = (button.dataset.searchUrl || '').trim();
    const providerKey = (button.dataset.searchProvider || PLAYWRIGHT_DEFAULT_SEARCH_PROVIDER).toLowerCase();
    const provider = getSearchProviderConfig(providerKey);
    const targetUrl = directUrl || buildSearchProviderUrl(query, providerKey);

    if (!targetUrl) {
        showWarning('No search target available for this action.');
        return;
    }

    const instruction = directUrl
        ? `Fetch latest information from ${directUrl}`
        : `Search the web for "${query}" using ${provider.label} and summarise the findings.`;

    button.disabled = true;

    hideMessages();
    showProgress();
    setProgress(0, directUrl ? 'Preparing to fetch page...' : `Preparing ${provider.label}...`);

    const assistantMessage = appendConversationMessage('assistant', renderAssistantLoading(directUrl ? 'Fetching page content...' : `Searching via ${provider.label}...`));

    setLlmStatus('info', directUrl ? 'Fetching suggested URL...' : `Running ${provider.label}...`);

    extractedData = null;
    updateLlmSendAvailability();

    try {
        const content = await extractContent(targetUrl);
        const record = { ...content, instruction };
        const extractionIndex = extractionHistory.push(record) - 1;
        record.extractionIndex = extractionIndex;
        extractedData = record;
        updateLlmSendAvailability();

        setProgress(100, 'Extraction complete!');
        hideProgress();
        showSuccess('Content extracted successfully!');

        updateConversationMessage(assistantMessage, renderAssistantLoading('Generating LLM response...'));

        const modelSelect = document.getElementById('ollamaModel');
        if (modelSelect && modelSelect.value) {
            setLlmStatus('info', 'Generating response with your Ollama model...');
            await sendToLLM(true, assistantMessage, extractionIndex);
        } else {
            const placeholder = '<p>Extraction complete. Choose an Ollama model under Settings, then click “Send to Ollama”.</p>';
            updateConversationMessage(assistantMessage, renderAssistantResponse(placeholder, record, extractionIndex));
            setLlmStatus('warning', 'Extraction ready. Choose an Ollama model and click “Send to Ollama” to continue.');
        }
    } catch (error) {
        setProgress(0, 'Error occurred');
        hideProgress();
        const messageHtml = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(assistantMessage, renderAssistantResponse(messageHtml, null));
        showError(`Failed to complete the task: ${error.message}`);
    } finally {
        button.disabled = false;
    }
}

async function extractContent(url) {
    const parser = new DOMParser();
    setProgress(25, 'Launching Playwright browser...');

    try {
        const renderResult = await extractWithPlaywright(url);
        const html = renderResult?.html || '';
        if (html && html.length > 0) {
            const doc = parser.parseFromString(html, 'text/html');
            setProgress(70, 'Processing content...');
            const content = await processExtractedContent(url, doc, 'playwright');
            const remoteMetadata = renderResult?.metadata;
            if (remoteMetadata && typeof remoteMetadata === 'object') {
                const mergedMetadata = { ...(content.metadata || {}) };
                Object.entries(remoteMetadata).forEach(([key, value]) => {
                    if (value === null || value === undefined || value === '') {
                        return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                        mergedMetadata[key] = {
                            ...(value || {}),
                            ...(mergedMetadata[key] || {})
                        };
                    } else if (!mergedMetadata[key]) {
                        mergedMetadata[key] = value;
                    }
                });
                mergedMetadata.playwright = {
                    ...(mergedMetadata.playwright || {}),
                    ...remoteMetadata
                };
                content.metadata = mergedMetadata;

                const metadataSummaryLines = [];
                if (remoteMetadata.title) {
                    metadataSummaryLines.push(`Title: ${remoteMetadata.title}`);
                }
                if (remoteMetadata.channel) {
                    metadataSummaryLines.push(`Channel: ${remoteMetadata.channel}`);
                }
                if (remoteMetadata.published) {
                    metadataSummaryLines.push(`Published: ${remoteMetadata.published}`);
                }
                if (remoteMetadata.viewCount) {
                    metadataSummaryLines.push(`Views: ${remoteMetadata.viewCount}`);
                }
                if (remoteMetadata.duration) {
                    metadataSummaryLines.push(`Duration: ${remoteMetadata.duration}`);
                }
                if (remoteMetadata.keywords) {
                    metadataSummaryLines.push(`Keywords: ${remoteMetadata.keywords}`);
                }
                if (remoteMetadata.description) {
                    metadataSummaryLines.push('');
                    metadataSummaryLines.push(remoteMetadata.description);
                }
                const metadataSummary = metadataSummaryLines.join('\n').trim();
                if (metadataSummary && !/Playwright Captured Video Summary:/i.test(content.content || '')) {
                    const injectedBlock = `Playwright Captured Video Summary:\n${metadataSummary}`;
                    content.content = content.content
                        ? `${injectedBlock}\n\n${content.content}`
                        : injectedBlock;
                }
            }
            return content;
        }
    } catch (error) {
        console.warn('Playwright extraction failed:', error);
        showWarning(`Playwright extraction failed: ${error.message}`);
    }

    setProgress(55, 'Falling back to static extraction...');
    try {
        const html = await tryMultipleExtractionMethods(url);
        if (html) {
            const doc = parser.parseFromString(html, 'text/html');
            setProgress(70, 'Processing content...');
            return await processExtractedContent(url, doc, 'direct');
        }
    } catch (error) {
        console.warn('Static extraction failed:', error);
    }

    throw new Error('Unable to retrieve content from the URL. Playwright and fallback methods failed.');
}

function extractOllamaMessageContent(message) {
    if (!message) {
        return '';
    }
    const content = message.content ?? '';
    if (typeof content === 'string') {
        return content;
    }
    if (Array.isArray(content)) {
        return content
            .map(part => (typeof part === 'string' ? part : part?.text || ''))
            .join('');
    }
    if (content && typeof content === 'object') {
        return content.text || content.content || '';
    }
    return '';
}

function isToolSupportError(status, text) {
    if (!status) {
        return false;
    }
    if (status === 404 || status === 405) {
        return true;
    }
    if (status === 400 && typeof text === 'string') {
        return /tool/i.test(text) || /unsupported/i.test(text);
    }
    return false;
}

async function chatWithOllama(options) {
    const {
        baseUrl,
        model,
        messages,
        enableTools = false,
        maxIterations = 4,
        onToolCall,
        onIteration
    } = options || {};

    if (!baseUrl || !model || !Array.isArray(messages)) {
        throw new Error('Invalid chat configuration.');
    }

    const conversation = messages.map(message => ({ ...message }));
    const toolExecutions = [];
    const toolCallTracker = new Map();
    let lastAssistantContent = '';
    let allowToolCalls = enableTools;

    for (let iteration = 0; iteration < Math.max(1, maxIterations); iteration += 1) {
        if (typeof onIteration === 'function') {
            try {
                onIteration(iteration, conversation);
            } catch (callbackError) {
                console.warn('chatWithOllama iteration callback failed:', callbackError);
            }
        }

        const body = {
            model,
            messages: conversation,
            stream: false
        };

        if (allowToolCalls) {
            body.tools = OLLAMA_DEFAULT_TOOLS;
            body.tool_choice = 'auto';
        } else if (enableTools) {
            body.tool_choice = 'none';
        }

        const response = await fetch(`${baseUrl}/api/chat`, {
            method: 'POST',
            mode: 'cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            const errorText = await response.text();
            const error = new Error(formatOllamaError(response.status, errorText || ''));
            if (enableTools && isToolSupportError(response.status, errorText)) {
                error.code = 'OLLAMA_TOOLS_UNSUPPORTED';
            }
            throw error;
        }

        const result = await response.json();
        const message = result?.message || result?.messages?.slice?.(-1)?.[0];
        if (!message) {
            return {
                result,
                finalContent: result?.response || '',
                toolExecutions
            };
        }

        const messageContent = extractOllamaMessageContent(message);
        if (messageContent) {
            lastAssistantContent = messageContent;
        }

        const toolCalls = enableTools ? (message.tool_calls || message.toolCalls || []) : [];
        const hasToolCalls = Array.isArray(toolCalls) && toolCalls.length > 0;

        if (hasToolCalls) {
            const assistantMsg = {
                role: message.role || 'assistant',
                content: message.content || '',
                tool_calls: toolCalls
            };
            conversation.push(assistantMsg);
            let successfulPlaywrightCall = false;
            for (const toolCall of toolCalls) {
                const signature = buildToolSignature(toolCall);
                const priorCount = toolCallTracker.get(signature) || 0;
                let previousExecution = null;
                if (priorCount > 0) {
                    previousExecution = [...toolExecutions].reverse().find(exec => exec._signature === signature && !exec.error);
                    if (previousExecution) {
                        console.warn(`Detected repeated tool call for signature ${signature}, aborting loop.`);
                        const fallbackContent = buildToolFallbackContent(
                            previousExecution,
                            'Tool loop stopped after repeated tool calls. Showing the most recent captured result instead.'
                        ) || previousExecution.display || previousExecution.content || '';
                        return {
                            result,
                            toolExecutions,
                            finalContent: fallbackContent,
                            toolLoopFallback: true,
                            toolLoopReason: 'duplicate_tool_call'
                        };
                    }
                }

                const toolDecisionMessage = announceToolDecision(toolCall);
                if (typeof onToolCall === 'function') {
                    try {
                        onToolCall(toolCall);
                    } catch (callbackError) {
                        console.warn('chatWithOllama tool callback failed:', callbackError);
                    }
                }
                let execution;
                try {
                    execution = await executeOllamaToolCall(toolCall);
                } catch (executionError) {
                    updateToolDecisionMessage(toolDecisionMessage, toolCall, null, executionError);
                    throw executionError;
                }
                const callId = toolCall?.id || `${execution.name || 'tool'}-${Date.now()}`;
                const executionRecord = {
                    ...execution,
                    callId,
                    _signature: signature
                };
                toolExecutions.push(executionRecord);
                toolCallTracker.set(signature, priorCount + 1);
                updateToolDecisionMessage(
                    toolDecisionMessage,
                    toolCall,
                    executionRecord,
                    executionRecord.error ? executionRecord.display || executionRecord.content || 'Tool execution failed.' : null
                );
                if (!executionRecord.error && executionRecord.name === 'render_with_playwright') {
                    successfulPlaywrightCall = true;
                }
                const toolMessage = {
                    role: 'tool',
                    content: execution.content,
                    name: execution.name
                };
                if (toolCall?.id) {
                    toolMessage.tool_call_id = toolCall.id;
                }
                conversation.push(toolMessage);
                if (executionRecord.error) {
                    return {
                        result,
                        toolExecutions,
                        toolError: executionRecord.display || executionRecord.content || 'Tool execution failed.'
                    };
                }
            }
            if (successfulPlaywrightCall) {
                allowToolCalls = false;
            }
            continue;
        }

        const content = extractOllamaMessageContent(message) || result?.response || '';
        return {
            result,
            message,
            finalContent: content,
            toolExecutions
        };
    }

    if (lastAssistantContent) {
        return {
            result: null,
            message: null,
            finalContent: lastAssistantContent,
            toolExecutions,
            toolLoopFallback: true
        };
    }

    const fallbackExecution = [...toolExecutions].reverse().find(exec => !exec.error) || null;
    if (fallbackExecution) {
        const fallbackContent = buildToolFallbackContent(
            fallbackExecution,
            'Tool loop stopped after repeated tool calls. Returning the most recent tool output.'
        ) || fallbackExecution.display || fallbackExecution.content || '';
        return {
            result: null,
            message: null,
            finalContent: fallbackContent,
            toolExecutions,
            toolLoopFallback: true
        };
    }

    throw new Error('Tool loop exceeded maximum iterations without producing an answer.');
}

async function generateInstructionAnswer(instruction, messageEl, decisionData) {
    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect || !modelSelect.value) {
        showError('Select an Ollama model before sending.');
        return;
    }

    updateConversationMessage(messageEl, renderAssistantLoading('Generating answer...'));
    showLlmProgress('Preparing answer...', 20);
    setLlmStatus('info', `Generating answer with ${modelSelect.value}...`);

    let baseUrl = 'http://localhost:11434';
    try {
        baseUrl = getOllamaBaseUrl();
    } catch (error) {
        hideLlmProgress();
        setLlmStatus('error', error.message);
        const errorHtml = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(
            messageEl,
            renderAssistantResponse(errorHtml, null)
        );
        return;
    }

    const reasonHtml = decisionData?.reason
        ? `<div class="assistant-llm-reason">${convertMarkdownToHtml(decisionData.reason)}</div>`
        : '';

    const systemPrompt = [
        'You are an assistant embedded in a web content extraction tool.',
        'You have access to these callable tools:',
        '- get_current_time(format: "iso" | "locale"): Returns the current system time and timezone.',
        `- render_with_playwright(url?, query?, search_provider?, wait_time?, include_images?, include_links?, include_metadata?, clean_content?): Renders live web pages or search results with the Playwright helper.`,
        'Always call get_current_time when you need exact or fresh date/time information.',
        'Call render_with_playwright whenever the user supplies a URL or asks you to browse a specific page before answering.',
        'When the user requests a web search or needs latest information, call render_with_playwright using the "query" field (default to the Google search provider unless the user states otherwise; you may offer alternatives via "search_provider").',
        'Use the returned HTML/metadata instead of guessing, and prefer refreshing the same origin rather than proxy mirrors.',
        'Follow the formatting guidance exactly:',
        LLM_RESPONSE_FORMAT_HINT
    ].join('\n');

    const messages = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: instruction }
    ];

    try {
        let chatResult;
        let usedTools = true;
        try {
            chatResult = await chatWithOllama({
                baseUrl,
                model: modelSelect.value,
                messages,
                enableTools: true,
                maxIterations: 6,
                onIteration: iteration => {
                    const status = iteration === 0 ? `Sending request to ${baseUrl}...` : 'Processing tool results...';
                    updateLlmProgress(45 + iteration * 12, status);
                },
                onToolCall: toolCall => {
                    const toolName = toolCall?.function?.name || 'tool';
                    setLlmStatus('info', `Running ${toolName} via Ollama tools...`);
                    updateLlmProgress(75, `Running ${toolName}...`);
                }
            });
        } catch (toolError) {
            if (toolError?.code === 'OLLAMA_TOOLS_UNSUPPORTED') {
                usedTools = false;
                console.warn('Ollama model appears not to support tools for instruction answers, retrying without them.');
                setLlmStatus('warning', 'Model does not support tools. Retrying without tool calls.');
                chatResult = await chatWithOllama({
                    baseUrl,
                    model: modelSelect.value,
                    messages,
                enableTools: false,
                maxIterations: 2,
                    onIteration: iteration => {
                        const status = iteration === 0 ? `Sending request to ${baseUrl}...` : 'Waiting for response...';
                        updateLlmProgress(45 + iteration * 15, status);
                    }
                });
            } else {
                throw toolError;
            }
        }

        const finalContent = chatResult?.finalContent || decisionData?.answer || '(No response text received.)';
        const toolExecutions = chatResult?.toolExecutions || [];
        if (chatResult?.toolError) {
            const errorHtml = `<div class="assistant-error">${escapeHtml(chatResult.toolError)}</div>${reasonHtml}`;
            updateConversationMessage(
                messageEl,
                renderAssistantResponse(errorHtml, null)
            );
            setLlmStatus('error', chatResult.toolError);
            return;
        }
        updateLlmProgress(100, 'LLM response received.');

        let llmHtml = renderLlmOutput(finalContent);
        if (reasonHtml) {
            llmHtml = reasonHtml + llmHtml;
        }
        if (toolExecutions.length > 0) {
            llmHtml += renderToolUsageSummary(toolExecutions);
        }

        updateConversationMessage(
            messageEl,
            renderAssistantResponse(llmHtml, null)
        );

        if (chatResult?.toolLoopFallback) {
            setLlmStatus('warning', `Response generated with ${modelSelect.value}. Tool loop stopped early after repeated calls.`);
        } else if (toolExecutions.length > 0) {
            const summary = toolExecutions.map(exec => exec.name || 'tool').join(', ');
            setLlmStatus('success', `Response generated with ${modelSelect.value}. Tools used: ${summary}.`);
        } else if (usedTools) {
            setLlmStatus('success', `Response generated with ${modelSelect.value}. No tools were required.`);
        } else {
            setLlmStatus('success', `Response generated with ${modelSelect.value}. (Tools unsupported.)`);
        }
    } catch (error) {
        console.error('Instruction answer generation failed:', error);
        updateLlmProgress(0, 'LLM request failed.');
        let errorMessage = error?.message || 'Failed to reach Ollama.';
        if (error instanceof TypeError || /Failed to fetch/i.test(errorMessage)) {
            const currentOrigin = window.location.origin || 'file://';
            errorMessage = [
                'Browser blocked the request to Ollama (likely CORS).',
                'Restart Ollama with CORS enabled, for example:',
                '  export OLLAMA_ORIGINS="*"',
                '  ollama serve',
                `or allow the UI origin explicitly: OLLAMA_ORIGINS="${currentOrigin}"`,
                `Attempted endpoint: ${baseUrl}/api/chat`
            ].join('\n');
        }
        setLlmStatus('error', errorMessage);
        const fallbackAnswer = decisionData?.answer ? renderLlmOutput(decisionData.answer) : '';
        const errorHtml = `<div class="assistant-error">${escapeHtml(errorMessage)}</div>${fallbackAnswer}`;
        updateConversationMessage(
            messageEl,
            renderAssistantResponse(errorHtml, null)
        );
        showError(`LLM request failed: ${errorMessage}`);
    } finally {
        setTimeout(() => hideLlmProgress(), 1500);
    }
}

async function sendToLLM(autoTriggered = false, messageEl = null, extractionIndex = extractedData?.extractionIndex) {
    const currentExtraction = typeof extractionIndex === 'number'
        ? extractionHistory[extractionIndex]
        : extractedData;

    if (!currentExtraction) {
        showError('Extract content before sending anything to the LLM.');
        return;
    }

    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect || !modelSelect.value) {
        showError('Select an Ollama model before sending.');
        return;
    }

    let assistantMessage = messageEl;
    if (!assistantMessage) {
        assistantMessage = appendConversationMessage('assistant', renderAssistantLoading('Generating LLM response...'));
    } else {
        updateConversationMessage(assistantMessage, renderAssistantLoading('Generating LLM response...'));
    }

    const selectedFormat = document.querySelector('input[name="llmPayloadFormat"]:checked')?.value || 'markdown';
    const sendButton = document.getElementById('llmSendButton');

    const formattedContent = selectedFormat === 'json'
        ? JSON.stringify(currentExtraction, null, 2)
        : convertToMarkdown(currentExtraction);

    const basePrompt = currentExtraction.instruction || 'Provide a concise summary of the extracted content.';
    const assembledPrompt = `${basePrompt}

---
Extracted content (${selectedFormat.toUpperCase()}):
${formattedContent}

${LLM_RESPONSE_FORMAT_HINT}`;

    showLlmProgress('Preparing payload...', 15);
    if (!autoTriggered) {
        setLlmStatus('', '');
    }
    if (sendButton) {
        sendButton.disabled = true;
    }

    let baseUrl = 'http://localhost:11434';
    try {
        baseUrl = getOllamaBaseUrl();
    } catch (error) {
        hideLlmProgress();
        setLlmStatus('error', error.message);
        const errorHtml = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(errorHtml, currentExtraction, extractionIndex)
        );
        if (sendButton) {
            sendButton.disabled = false;
        }
        return;
    }

    const chatMessages = [
        {
            role: 'system',
            content: [
                'You are an assistant embedded in a web content extraction tool.',
                'Use any provided tools when they help you answer accurately.',
                'Available tools: get_current_time (returns the current system time) and render_with_playwright (renders live web pages or search results with the Playwright helper).',
                'Whenever the user references a URL from the extracted data, call render_with_playwright on that URL before answering.',
                'When the user asks to browse, search, or gather up-to-date information, call render_with_playwright using the "query" argument (default to the Google search provider unless a different one is specified; offer options when helpful).',
                'Prefer re-rendering the same origin with Playwright instead of redirecting to mirrors or cached proxies.',
                'Follow the formatting guidance exactly:',
                LLM_RESPONSE_FORMAT_HINT
            ].join(' ')
        },
        {
            role: 'user',
            content: assembledPrompt
        }
    ];

    try {
        let chatResult;
        let usedTools = true;
        try {
            chatResult = await chatWithOllama({
                baseUrl,
                model: modelSelect.value,
                messages: chatMessages,
                enableTools: true,
                maxIterations: 6,
                onIteration: iteration => {
                    const status = iteration === 0 ? `Sending request to ${baseUrl}...` : 'Processing tool results...';
                    updateLlmProgress(45 + iteration * 12, status);
                },
                onToolCall: toolCall => {
                    const toolName = toolCall?.function?.name || 'tool';
                    setLlmStatus('info', `Running ${toolName} via Ollama tools...`);
                    updateLlmProgress(75, `Running ${toolName}...`);
                }
            });
        } catch (toolError) {
            if (toolError?.code === 'OLLAMA_TOOLS_UNSUPPORTED') {
                usedTools = false;
                console.warn('Ollama model appears not to support tools, retrying without them.');
                setLlmStatus('warning', 'Model does not support tools. Retrying without tool calls.');
                chatResult = await chatWithOllama({
                    baseUrl,
                    model: modelSelect.value,
                    messages: chatMessages,
                enableTools: false,
                maxIterations: 2,
                    onIteration: iteration => {
                        const status = iteration === 0 ? `Sending request to ${baseUrl}...` : 'Waiting for response...';
                        updateLlmProgress(45 + iteration * 15, status);
                    }
                });
            } else {
                throw toolError;
            }
        }

        const finalContent = chatResult?.finalContent || '(No response text received.)';
        const toolExecutions = chatResult?.toolExecutions || [];
        if (chatResult?.toolError) {
            const errorHtml = `<div class="assistant-error">${escapeHtml(chatResult.toolError)}</div>`;
            updateConversationMessage(
                assistantMessage,
                renderAssistantResponse(errorHtml, currentExtraction, extractionIndex)
            );
            setLlmStatus('error', chatResult.toolError);
            return;
        }
        updateLlmProgress(100, 'LLM response received.');

        let llmHtml = renderLlmOutput(finalContent);
        if (toolExecutions.length > 0) {
            llmHtml += renderToolUsageSummary(toolExecutions);
        }

        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(llmHtml, currentExtraction, extractionIndex)
        );

        if (chatResult?.toolLoopFallback) {
            setLlmStatus('warning', `Response generated with ${modelSelect.value}. Tool loop stopped early after repeated calls.`);
        } else if (toolExecutions.length > 0) {
            const summary = toolExecutions.map(exec => exec.name || 'tool').join(', ');
            setLlmStatus('success', `Response generated with ${modelSelect.value}. Tools used: ${summary}.`);
        } else if (usedTools) {
            setLlmStatus('success', `Response generated with ${modelSelect.value}. No tools were required.`);
        } else {
            setLlmStatus('success', `Response generated with ${modelSelect.value}.`);
        }
    } catch (error) {
        console.error('Ollama request failed:', error);
        updateLlmProgress(0, 'LLM request failed.');
        let errorMessage = error?.message || 'Failed to reach Ollama.';
        if (error instanceof TypeError || /Failed to fetch/i.test(errorMessage)) {
            const currentOrigin = window.location.origin || 'file://';
            errorMessage = [
                'Browser blocked the request to Ollama (likely CORS).',
                'Restart Ollama with CORS enabled, for example:',
                '  export OLLAMA_ORIGINS="*"',
                '  ollama serve',
                `or allow the UI origin explicitly: OLLAMA_ORIGINS="${currentOrigin}"`,
                `Attempted endpoint: ${baseUrl}/api/generate`
            ].join('\n');
        }
        setLlmStatus('error', errorMessage);
        const errorHtml = `<div class="assistant-error">${escapeHtml(errorMessage)}</div>`;
        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(errorHtml, currentExtraction, extractionIndex)
        );
        showError(`LLM request failed: ${errorMessage}`);
    } finally {
        setTimeout(() => hideLlmProgress(), 1500);
        if (sendButton) {
            sendButton.disabled = !(currentExtraction && modelSelect && modelSelect.value);
        }
        updateLlmSendAvailability();
    }
}

function setLlmStatus(type, message) {
    if (!conversationEl) {
        return;
    }

    const trimmedMessage = (message || '').trim();
    if (!trimmedMessage) {
        if (statusMessageEl && conversationEl.contains(statusMessageEl)) {
            conversationEl.removeChild(statusMessageEl);
        }
        statusMessageEl = null;
        return;
    }

    if (!statusMessageEl || !conversationEl.contains(statusMessageEl)) {
        statusMessageEl = appendConversationMessage('assistant status', '');
        if (!statusMessageEl) {
            return;
        }
        statusMessageEl.classList.add('status');
    }

    // Ensure the status message stays at the end of the conversation
    try {
        conversationEl.appendChild(statusMessageEl);
    } catch (error) {
        console.warn('Unable to reposition status message:', error);
    }

    const bubble = statusMessageEl.querySelector('.conversation-bubble');
    if (!bubble) {
        return;
    }

    const safeType = (type || '').toLowerCase();
    statusMessageEl.classList.remove('status-info', 'status-success', 'status-warning', 'status-error');
    if (safeType) {
        statusMessageEl.classList.add(`status-${safeType}`);
    }

    const safeHtml = escapeHtml(trimmedMessage).replace(/\n/g, '<br>');
    bubble.innerHTML = `
        <div class="bubble-header">
            <span class="bubble-label">System</span>
        </div>
        <div class="status-message-text">${safeHtml}</div>
    `;
    requestAnimationFrame(scrollConversationToEnd);
}

function showLlmProgress(message, percent = 0) {
    const progressElement = document.getElementById('llmProgress');
    if (!progressElement) {
        return;
    }
    progressElement.style.display = 'block';
    updateLlmProgress(percent, message);
}

function updateLlmProgress(percent, message) {
    const fillElement = document.getElementById('llmProgressFill');
    const statusText = document.getElementById('llmStatusText');
    if (fillElement) {
        const clamped = Math.max(0, Math.min(100, percent));
        fillElement.style.width = `${clamped}%`;
    }
    if (statusText) {
        statusText.textContent = message || '';
    }
}

function hideLlmProgress() {
    const progressElement = document.getElementById('llmProgress');
    if (!progressElement) {
        return;
    }
    progressElement.style.display = 'none';
    updateLlmProgress(0, '');
}

function normalizeOllamaBaseUrl(value) {
    if (!value) {
        return 'http://localhost:11434';
    }
    let trimmed = value.trim();
    if (!/^https?:\/\//i.test(trimmed)) {
        trimmed = `http://${trimmed}`;
    }
    try {
        const parsed = new URL(trimmed);
        return parsed.origin;
    } catch (error) {
        console.warn('Invalid Ollama server URL provided; defaulting to localhost.', error);
        return 'http://localhost:11434';
    }
}

function getOllamaBaseUrl() {
    const input = document.getElementById('ollamaServer');
    if (!input) {
        throw new Error('Ollama server input not found.');
    }
    const normalized = normalizeOllamaBaseUrl(input.value);
    input.value = normalized;
    return normalized;
}

function describeOllamaModel(model) {
    if (!model) {
        return null;
    }

    const primary = (model.model || model.name || model.tag || '').trim();
    if (!primary) {
        return null;
    }

    return { value: primary, label: primary };
}

function buildDefaultModelOptions() {
    return DEFAULT_OLLAMA_MODELS.map(name => ({ value: name, label: name }));
}

function dedupeModelOptions(options) {
    const map = new Map();
    options.forEach(option => {
        if (!option || !option.value) {
            return;
        }
        if (!map.has(option.value)) {
            map.set(option.value, option);
        }
    });
    return Array.from(map.values());
}

function prioritizeModelOptions(options) {
    return options
        .slice()
        .sort((a, b) => {
            if (a.value === PREFERRED_OLLAMA_MODEL) return -1;
            if (b.value === PREFERRED_OLLAMA_MODEL) return 1;
            const aCloud = /cloud/i.test(a.value);
            const bCloud = /cloud/i.test(b.value);
            if (aCloud && !bCloud) return -1;
            if (!aCloud && bCloud) return 1;
            return a.label.localeCompare(b.label);
        });
}

function hasModelOption(options, value) {
    return options.some(option => option.value === value || option.label === value);
}

function formatBytes(value) {
    if (!Number.isFinite(value)) {
        return null;
    }
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = value;
    let index = 0;
    while (size >= 1024 && index < units.length - 1) {
        size /= 1024;
        index += 1;
    }
    const precision = size >= 100 || index === 0 ? 0 : 1;
    return `${size.toFixed(precision)} ${units[index]}`;
}

async function pullOllamaModel(baseUrl, modelName, onUpdate) {
    const response = await fetch(`${baseUrl}/api/pull`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: modelName, stream: true })
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText || 'Request failed'}`);
    }

    const processEvent = event => {
        if (!event) {
            return { success: false };
        }
        if (event.error) {
            throw new Error(event.error);
        }
        if (typeof onUpdate === 'function') {
            try {
                onUpdate(event);
            } catch (callbackError) {
                console.warn('Ollama pull status callback error:', callbackError);
            }
        }

        const statusText = (event.status || '').toLowerCase();
        let isSuccess = /success|already exists/.test(statusText);

        const completedValue = Number(event.completed);
        const totalValue = Number(event.total);
        if (!isSuccess && Number.isFinite(completedValue) && Number.isFinite(totalValue) && totalValue > 0) {
            isSuccess = completedValue >= totalValue;
        }

        return { success: isSuccess };
    };

    let pullCompleted = false;

    if (response.body && response.body.getReader) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                break;
            }
            buffer += decoder.decode(value, { stream: true });

            let newlineIndex = buffer.indexOf('\n');
            while (newlineIndex !== -1) {
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                if (line) {
                    try {
                        const event = JSON.parse(line);
                        const { success } = processEvent(event);
                        pullCompleted = pullCompleted || success;
                    } catch (parseError) {
                        console.warn('Failed to parse Ollama pull message:', parseError, line);
                    }
                }
                newlineIndex = buffer.indexOf('\n');
            }
        }

        const remaining = buffer.trim();
        if (remaining) {
            try {
                const event = JSON.parse(remaining);
                const { success } = processEvent(event);
                pullCompleted = pullCompleted || success;
            } catch (parseError) {
                console.warn('Failed to parse final Ollama pull message:', parseError, remaining);
            }
        }
    } else {
        const text = await response.text();
        text.split(/\r?\n/).forEach(line => {
            const trimmed = line.trim();
            if (!trimmed) {
                return;
            }
            try {
                const event = JSON.parse(trimmed);
                const { success } = processEvent(event);
                pullCompleted = pullCompleted || success;
            } catch (parseError) {
                console.warn('Failed to parse Ollama pull message:', parseError, trimmed);
            }
        });
    }

    if (!pullCompleted) {
        throw new Error('Model pull did not complete successfully.');
    }
}

async function ensurePreferredModelAvailable(baseUrl, triggeredByUser) {
    const modelName = PREFERRED_OLLAMA_MODEL;
    setLlmStatus('info', `Default Ollama model missing. Pulling ${modelName}...`);

    const updateStatus = event => {
        if (!event) {
            return;
        }
        const parts = [];
        if (event.status) {
            parts.push(event.status);
        }
        const completedValue = Number(event.completed);
        const totalValue = Number(event.total);
        if (Number.isFinite(completedValue) && Number.isFinite(totalValue) && totalValue > 0) {
            const percent = Math.max(0, Math.min(100, Math.round((completedValue / totalValue) * 100)));
            const completed = formatBytes(completedValue);
            const total = formatBytes(totalValue);
            if (completed && total) {
                parts.push(`${percent}% (${completed} / ${total})`);
            } else {
                parts.push(`${percent}%`);
            }
        } else if (Number.isFinite(completedValue)) {
            const downloaded = formatBytes(completedValue);
            if (downloaded) {
                parts.push(`${downloaded} downloaded`);
            }
        }

        const detail = parts.join(' - ') || 'Working...';
        setLlmStatus('info', `Pulling ${modelName}: ${detail}`);
    };

    try {
        await pullOllamaModel(baseUrl, modelName, updateStatus);
        setLlmStatus('success', `Model ${modelName} is ready to use.`);
        if (triggeredByUser) {
            showSuccess(`Ollama model ${modelName} pulled successfully.`);
        }
        return true;
    } catch (error) {
        console.error('Failed to pull preferred Ollama model:', error);
        setLlmStatus('error', `Unable to pull ${modelName}: ${error.message}`);
        if (triggeredByUser) {
            showError(`Failed to pull ${modelName}: ${error.message}`);
        }
        return false;
    }
}

async function loadOllamaModels(triggeredByUser = false, skipEnsurePreferred = false) {
    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect) {
        return;
    }

    const sendButton = document.getElementById('llmSendButton');
    if (sendButton) {
        sendButton.disabled = true;
    }

    if (triggeredByUser) {
        setLlmStatus('info', 'Refreshing model list from Ollama...');
    }

    let models = [];
    let baseUrl = '';
    try {
        baseUrl = getOllamaBaseUrl();
        if (triggeredByUser) {
            setLlmStatus('info', `Connecting to ${baseUrl}...`);
        }

        const response = await fetch(`${baseUrl}/api/tags`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        if (Array.isArray(data.models)) {
            models = data.models
                .map(describeOllamaModel)
                .filter(Boolean);
        } else {
            models = [];
        }

        if (models.length === 0) {
            throw new Error('No models reported by Ollama.');
        }

        models = prioritizeModelOptions(dedupeModelOptions(models));

        if (!skipEnsurePreferred && baseUrl && !hasModelOption(models, PREFERRED_OLLAMA_MODEL)) {
            const ensured = await ensurePreferredModelAvailable(baseUrl, triggeredByUser);
            if (ensured) {
                return loadOllamaModels(triggeredByUser, true);
            }
        }

        const previewList = models.slice(0, 6).map(model => model.value).join(', ');
        const previewSuffix = models.length > 6 ? ' …' : '';
        setLlmStatus(
            'success',
            `Loaded ${models.length} model${models.length === 1 ? '' : 's'} from Ollama: ${previewList}${previewSuffix}`
        );
    } catch (error) {
        console.warn('Unable to load Ollama models:', error);
        if (triggeredByUser) {
            setLlmStatus('error', `Failed to refresh models: ${error.message}`);
        } else {
            setLlmStatus('warning', 'Could not reach Ollama. Using default model list.');
        }
        models = prioritizeModelOptions(dedupeModelOptions(buildDefaultModelOptions()));
    }

    if (models.length === 0) {
        models = prioritizeModelOptions(dedupeModelOptions(buildDefaultModelOptions()));
    }

    modelSelect.innerHTML = models
        .map(model => `<option value="${model.value}">${model.label}</option>`)
        .join('');

    const preferred = modelSelect.dataset.preferredModel;
    if (preferred) {
        const preferredOption = models.find(model => model.value === preferred || model.label === preferred);
        if (preferredOption) {
            modelSelect.value = preferredOption.value;
        }
    }
    delete modelSelect.dataset.preferredModel;

    if (!modelSelect.value && hasModelOption(models, PREFERRED_OLLAMA_MODEL)) {
        modelSelect.value = PREFERRED_OLLAMA_MODEL;
    }

    if (!modelSelect.value && models.length > 0) {
        modelSelect.value = models[0].value;
    }

    setTimeout(() => updateLlmSendAvailability(), 0);
}

function updateLlmSendAvailability() {
    const sendButton = document.getElementById('llmSendButton');
    const modelSelect = document.getElementById('ollamaModel');
    if (!sendButton || !modelSelect) {
        return;
    }
    const hasModel = Boolean(modelSelect.value);
    sendButton.disabled = !(hasModel && extractedData);
}

function hasMeaningfulHtml(html) {
    if (!html) {
        return false;
    }
    const trimmed = html.trim();
    if (!trimmed) {
        return false;
    }
    const textOnly = trimmed.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
    return trimmed.length >= 20 || textOnly.length >= 20;
}


async function tryMultipleExtractionMethods(url) {
            let html = '';
            const sanitizedUrl = url.trim();
            const strippedUrl = sanitizedUrl.replace(/^https?:\/\//, '');
            const hasWwwPrefix = strippedUrl.startsWith('www.');
            
            // Method 1: Try CORS proxy (primary method)
            try {
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(sanitizedUrl)}`;
                const response = await fetch(proxyUrl);
                if (response.ok) {
                    html = await response.text();
                    if (hasMeaningfulHtml(html)) {
                        return html;
                    }
                }
            } catch (proxyError) {
                console.warn('CORS proxy failed:', proxyError);
            }
            
            // Method 2: Try text-only mirror via r.jina.ai (http)
            try {
                const textiseUrl = `https://r.jina.ai/http://${strippedUrl}`;
                const response = await fetch(textiseUrl);
                if (response.ok) {
                    html = await response.text();
                    if (hasMeaningfulHtml(html)) {
                        return html;
                    }
                }
            } catch (textiseError) {
                console.warn('Textise service failed:', textiseError);
            }
            
            // Method 3: Try with www prefix if missing
            if (!hasWwwPrefix) {
                try {
                    const textiseAltUrl = `https://r.jina.ai/http://www.${strippedUrl}`;
                    const response = await fetch(textiseAltUrl);
                    if (response.ok) {
                        html = await response.text();
                        if (hasMeaningfulHtml(html)) {
                            return html;
                        }
                    }
                } catch (textiseAltError) {
                    console.warn('Alternative textise service failed:', textiseAltError);
                }
            }
            
            // Method 4: Try forcing https upstream
            try {
                const textiseHttpsUrl = `https://r.jina.ai/http://https://${strippedUrl}`;
                const response = await fetch(textiseHttpsUrl);
                if (response.ok) {
                    html = await response.text();
                    if (hasMeaningfulHtml(html)) {
                        return html;
                    }
                }
            } catch (textiseHttpsError) {
                console.warn('HTTPS textise service failed:', textiseHttpsError);
            }
            
            throw new Error('All extraction methods failed. The page may be blocking access or require JavaScript.');
        }

        async function tryTextExtractionServices(url) {
            const sanitizedUrl = url.trim();
            const strippedUrl = sanitizedUrl.replace(/^https?:\/\//, '');
            const services = [
                `https://r.jina.ai/http://${strippedUrl}`,
                `https://r.jina.ai/http://https://${strippedUrl}`
            ];
            
            if (!strippedUrl.startsWith('www.')) {
                services.push(`https://r.jina.ai/http://www.${strippedUrl}`);
            }
            
            for (const serviceUrl of services) {
                try {
                    const response = await fetch(serviceUrl);
                    if (response.ok) {
                        const html = await response.text();
                        if (hasMeaningfulHtml(html) && !html.includes('JavaScript is disabled')) {
                            return html;
                        }
                    }
                } catch (error) {
                    console.warn(`Service ${serviceUrl} failed:`, error);
                }
            }
            
            return null;
        }

        async function tryWaybackMachine(url) {
            try {
                const waybackUrl = `https://webcache.googleusercontent.com/search?q=cache:${url}`;
                const response = await fetch(waybackUrl);
                if (response.ok) {
                    const html = await response.text();
                    if (hasMeaningfulHtml(html) && !html.includes('JavaScript is disabled')) {
                        return html;
                    }
                }
            } catch (error) {
                console.warn('Wayback Machine failed:', error);
            }
            
            return null;
        }

        function isJavaScriptRequired(doc) {
            const bodyText = (doc.body?.textContent || '').toLowerCase();
            const titleText = (doc.title || '').toLowerCase();
            
            // Check for common JavaScript-disabled messages
            const jsDisabledPatterns = [
                'javascript is disabled',
                'javascript is required',
                'enable javascript',
                'please enable javascript',
                'this site requires javascript',
                'verification required',
                'not a robot',
                'cloudflare',
                'checking your browser',
                'enable javascript and reload'
            ];
            
            // Check if page contains JavaScript-disabled messages
            for (const pattern of jsDisabledPatterns) {
                if (bodyText.includes(pattern) || titleText.includes(pattern)) {
                    return true;
                }
            }
            
            // Check if page is mostly empty (likely requires JS)
            const textLength = bodyText.length;
            const elementCount = doc.querySelectorAll('*').length;
            
            if (textLength < 50 && elementCount < 10) {
                return true;
            }
            
            // Check for common JS-required indicators
            const jsIndicators = [
                doc.querySelector('[data-require-js]'),
                doc.querySelector('.js-required'),
                doc.querySelector('#noscript'),
                doc.querySelector('meta[name="generator"][content*="javascript"]'),
                doc.querySelector('script[src*="app"]'),
                doc.querySelector('script[src*="bundle"]')
            ];
            
            return jsIndicators.some(indicator => indicator !== null);
        }

        function processExtractedContent(url, doc, extractionMethod = 'direct') {
            // Wait for dynamic content simulation
            const waitTime = parseInt(document.getElementById('waitTime').value);
            setProgress(70, 'Processing content...');
            
            // Simulate waiting for dynamic content
            return new Promise(resolve => {
                setTimeout(() => {
                    setProgress(80, 'Formatting for LLM...');
                    
                    // Extract content
                    const content = {
                        url: url,
                        timestamp: new Date().toISOString(),
                        metadata: extractMetadata(doc),
                        content: extractMainContent(doc),
                        links: extractLinks(doc),
                        images: extractImages(doc),
                        structure: extractStructure(doc),
                        extractionMethod: extractionMethod
                    };
                    
                    resolve(content);
                }, Math.min(waitTime, 2000)); // Cap wait time for alternative methods
            });
        }

        function getPlaywrightEndpoint(mode = playwrightHelperMode) {
            if (mode === 'embedded') {
                return getEmbeddedPlaywrightEndpoint();
            }
            const input = playwrightServerInput || document.getElementById('playwrightServer');
            let baseUrl = (input?.value || '').trim();
            if (!baseUrl) {
                baseUrl = 'http://localhost:3050';
            }
            try {
                const normalized = new URL(baseUrl);
                let path = normalized.pathname || '';
                if (path === '/') {
                    path = '';
                } else {
                    path = path.replace(/\/+$/, '');
                }
                return `${normalized.origin}${path}/extract-with-playwright`;
            } catch (error) {
                throw new Error('Invalid Playwright server URL. Please provide a valid address (e.g., http://localhost:3050).');
            }
        }

        async function extractWithPlaywright(url) {
            try {
                setProgress(35, 'Starting Playwright browser...');
                const payload = await requestPlaywrightHtml(url);
                setProgress(65, 'Browser extraction successful...');
                return payload;
            } catch (error) {
                if (error?.code === 'PLAYWRIGHT_HELPER_UNREACHABLE') {
                    throw error;
                }
                if (error.message.includes('Failed to fetch') || error.message.includes('Invalid Playwright server URL')) {
                    showPlaywrightInstructions(error.message);
                    throw new Error('Playwright server not reachable. See instructions below to set up browser automation.');
                }
                throw error;
            }
        }

        function showPlaywrightInstructions(detailsMessage) {
            const mode = playwrightHelperMode || 'embedded';
            const warningElement = document.getElementById('warningMessage');

            const renderWarning = (html) => {
                warningElement.innerHTML = detailsMessage ? `<p>${detailsMessage}</p>${html}` : html;
                warningElement.style.display = 'block';
                warningElement.style.maxHeight = '400px';
                warningElement.style.overflow = 'auto';
            };

            if (mode === 'embedded') {
                const endpoint = getEmbeddedPlaywrightEndpoint();
                const embeddedSnippet = `const { chromium } = require('playwright');
const express = require('express');
const app = express();

const USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36';
const VIEWPORT = { width: 1365, height: 768 };
const LOCALE = 'en-US';
const TIMEZONE = 'America/Los_Angeles';
const ACCEPT_LANGUAGE = 'en-US,en;q=0.9';
const SEC_CH_UA = '"Chromium";v="124", "Google Chrome";v="124", "Not:A-Brand";v="99"';
const SEC_CH_UA_PLATFORM = '"Windows"';

let browser;
async function ensureBrowser() {
    if (!browser) {
        browser = await chromium.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
    }
    return browser;
}

function buildHeaders(targetUrl) {
    const headers = {
        'Accept-Language': ACCEPT_LANGUAGE,
        'Sec-CH-UA': SEC_CH_UA,
        'Sec-CH-UA-Mobile': '?0',
        'Sec-CH-UA-Platform': SEC_CH_UA_PLATFORM
    };
    try {
        const parsed = new URL(targetUrl);
        headers.Referer = \`\${parsed.origin}/\`;
    } catch (error) {}
    return headers;
}

app.use(express.json({ limit: '2mb' }));

app.post('/api/playwright/extract', async (req, res) => {
    const { url, waitTime = 800, options = {} } = req.body || {};
    if (!url) return res.json({ success: false, error: 'Missing url' });
    try {
        const browser = await ensureBrowser();
        const context = await browser.newContext({
            userAgent: USER_AGENT,
            viewport: VIEWPORT,
            locale: LOCALE,
            timezoneId: TIMEZONE
        });
        await context.addInitScript(() => {
            Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
            if (!window.chrome) {
                window.chrome = { runtime: {} };
            }
        });
        await context.setExtraHTTPHeaders(buildHeaders(url));
        const page = await context.newPage();
        if (options.blockMedia) {
            await page.route('**/*.{png,jpg,jpeg,gif,svg,webp,mp4,mp3,woff,woff2}', route => route.abort());
            await page.route('**/*.{css,map}', route => route.abort());
        }
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
        if (options.fastSelector) {
            await page.waitForSelector(options.fastSelector, { timeout: 1500 }).catch(() => {});
        }
        await page.waitForTimeout(Math.max(200, Math.min(waitTime, 1200)));
        const html = await page.content();
        await context.close();
        res.json({ success: true, html });
    } catch (error) {
        console.error('Playwright error:', error);
        res.json({ success: false, error: error.message });
    }
});

const PORT = process.env.PORT || 3050;
app.listen(PORT, () => {
    console.log('⚡ Embedded Playwright helper listening on ' + PORT);
});`;

                const instructions = `
                    <h3>⚡ Embedded Playwright Helper Required</h3>
                    <p>The fast embedded mode keeps a Chromium instance warm inside this app for near-instant renders.</p>
                    <h4>Step 1: Install dependencies</h4>
                    <pre><code>npm install playwright express</code></pre>
                    <h4>Step 2: Create <code>embedded-helper.js</code></h4>
                    <pre><code>${embeddedSnippet}</code></pre>
                    <h4>Step 3: Start the helper</h4>
                    <pre><code>node embedded-helper.js</code></pre>
                    <h4>Step 4: Try again</h4>
                    <p>The UI will call <code>${endpoint}</code>. Because the browser stays alive and heavy assets are blocked, repeat renders typically finish in under a second.</p>
                `;
                renderWarning(instructions);
                return;
            }

            const endpoint = (() => {
                try {
                    return getPlaywrightEndpoint('container');
                } catch {
                    return 'http://localhost:3050/extract-with-playwright';
                }
            })();
            const baseForInput = endpoint.replace(/\/extract-with-playwright$/, '');

            const serverSnippet = `const { chromium } = require('playwright');
const express = require('express');
const app = express();

const USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36';
const VIEWPORT = { width: 1365, height: 768 };
const LOCALE = 'en-US';
const TIMEZONE = 'America/Los_Angeles';
const ACCEPT_LANGUAGE = 'en-US,en;q=0.9';
const SEC_CH_UA = '"Chromium";v="124", "Google Chrome";v="124", "Not:A-Brand";v="99"';
const SEC_CH_UA_PLATFORM = '"Windows"';

let browser;
async function ensureBrowser() {
    if (!browser) {
        browser = await chromium.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
    }
    return browser;
}

function buildHeaders(targetUrl) {
    const headers = {
        'Accept-Language': ACCEPT_LANGUAGE,
        'Sec-CH-UA': SEC_CH_UA,
        'Sec-CH-UA-Mobile': '?0',
        'Sec-CH-UA-Platform': SEC_CH_UA_PLATFORM
    };
    try {
        const parsed = new URL(targetUrl);
        headers.Referer = \`\${parsed.origin}/\`;
    } catch (error) {}
    return headers;
}

app.use(express.json({ limit: '2mb' }));

app.post('/extract-with-playwright', async (req, res) => {
    const { url, waitTime = 1500, options = {} } = req.body || {};
    if (!url) return res.json({ success: false, error: 'Missing url' });
    try {
        const browser = await ensureBrowser();
        const context = await browser.newContext({
            userAgent: USER_AGENT,
            viewport: VIEWPORT,
            locale: LOCALE,
            timezoneId: TIMEZONE
        });
        await context.addInitScript(() => {
            Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
            if (!window.chrome) {
                window.chrome = { runtime: {} };
            }
        });
        await context.setExtraHTTPHeaders(buildHeaders(url));
        const page = await context.newPage();
        if (options.blockMedia) {
            await page.route('**/*.{png,jpg,jpeg,gif,svg,webp,mp4,mp3,woff,woff2}', route => route.abort());
            await page.route('**/*.{css,map}', route => route.abort());
        }
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 30000 });
        await page.waitForTimeout(Math.max(350, Math.min(waitTime, 2000)));
        const html = await page.content();
        await context.close();
        res.json({ success: true, html });
    } catch (error) {
        console.error('Playwright error:', error);
        res.json({ success: false, error: error.message });
    }
});

const PORT = process.env.PORT || 3050;
app.listen(PORT, () => {
    console.log('🚀 Playwright extraction server running on port ' + PORT);
    console.log('Browser kept warm for near-instant renders.');
});`;

            const instructions = `
                <h3>🚀 Playwright Helper Required</h3>
                <p>Run the helper in Docker or on another host. It keeps a Chromium browser warm, blocks heavy resources, and honours short wait times.</p>
                <h4>Step 1: Install dependencies</h4>
                <pre><code>npm install playwright express</code></pre>
                <h4>Step 2: Create <code>extract-server.js</code></h4>
                <pre><code>${serverSnippet}</code></pre>
                <h4>Step 3: Start the helper</h4>
                <pre><code>node extract-server.js
# or build & run the Docker helper
# docker build -t playwright-extractor -f docker/Dockerfile .
# docker run --rm -p 3050:3050 playwright-extractor</code></pre>
                <h4>Step 4: Point this UI at the helper</h4>
                <p>Set the Playwright Server URL to <code>${baseForInput}</code> (or your host) and retry the extraction.</p>
            `;

            renderWarning(instructions);
        }
        function extractMetadata(doc) {
            if (!document.getElementById('includeMetadata').checked) {
                return {};
            }

            const metadata = {
                title: doc.title || 'No title',
                description: getMetaContent(doc, 'description'),
                keywords: getMetaContent(doc, 'keywords'),
                author: getMetaContent(doc, 'author'),
                canonical: getCanonicalUrl(doc),
                language: doc.documentElement.lang || 'unknown',
                viewport: getMetaContent(doc, 'viewport')
            };

            // Open Graph data
            const ogData = {};
            ['title', 'description', 'image', 'url', 'type', 'site_name'].forEach(prop => {
                const content = getMetaContent(doc, `og:${prop}`, 'property');
                if (content) ogData[prop] = content;
            });

            if (Object.keys(ogData).length > 0) {
                metadata.openGraph = ogData;
            }

            return metadata;
        }

        function extractMainContent(doc) {
            try {
                const options = {
                    includeImages: document.getElementById('includeImages').checked,
                    includeLinks: document.getElementById('includeLinks').checked,
                    cleanContent: document.getElementById('cleanContent').checked
                };

                let content = '';
                
                // Try to find main content area
                const mainSelectors = [
                    'main', 'article', '[role="main"]', 
                    '.content', '.main-content', '#content',
                    '.post-content', '.entry-content'
                ];
                
                let mainElement = null;
                for (const selector of mainSelectors) {
                    mainElement = doc.querySelector(selector);
                    if (mainElement) break;
                }
                
                // Fallback to body if no main content found
                if (!mainElement) {
                    mainElement = doc.body;
                }

                // Remove unwanted elements
                const unwantedSelectors = [
                    'script', 'style', 'nav', 'header', 'footer', 
                    '.sidebar', '.menu', '.navigation', '.ads',
                    '.advertisement', '.social-share'
                ];
                
                const clone = mainElement.cloneNode(true);
                unwantedSelectors.forEach(selector => {
                    const elements = clone.querySelectorAll(selector);
                    elements.forEach(el => el.remove());
                });

                // Extract text content
                if (options.cleanContent) {
                    content = cleanTextContent(clone);
                } else {
                    content = clone.textContent || clone.innerText || '';
                }

                // Add image alt text if requested
                if (options.includeImages) {
                    const images = clone.querySelectorAll('img');
                    if (images && images.length > 0) {
                        const imageTexts = Array.from(images)
                            .map(img => img.alt || img.title || '[Image]')
                            .filter(text => text && text !== '[Image]');
                        
                        if (imageTexts && imageTexts.length > 0) {
                            content += '\n\nIMAGES:\n' + imageTexts.join('\n');
                        }
                    }
                }

                // Add link text if requested
                if (options.includeLinks) {
                    const links = clone.querySelectorAll('a[href]');
                    if (links && links.length > 0) {
                        const linkTexts = Array.from(links)
                            .map(link => (link.textContent || '').trim())
                            .filter(text => text.length > 0);
                        
                        if (linkTexts && linkTexts.length > 0) {
                            content += '\n\nLINKS:\n' + linkTexts.join('\n');
                        }
                    }
                }

                return content.trim();
            } catch (error) {
                console.warn('Error extracting main content:', error);
                return doc.body ? (doc.body.textContent || doc.body.innerText || '').trim() : '';
            }
        }

        function extractLinks(doc) {
            try {
                const links = Array.from(doc.querySelectorAll('a[href]'))
                    .map(link => ({
                        text: (link.textContent || '').trim(),
                        href: link.href || '',
                        title: link.title || ''
                    }))
                    .filter(link => link && link.text && link.text.length > 0);
                
                return links || [];
            } catch (error) {
                console.warn('Error extracting links:', error);
                return [];
            }
        }

        function extractImages(doc) {
            const images = Array.from(doc.querySelectorAll('img'))
                .map(img => ({
                    src: img.src,
                    alt: img.alt || '',
                    title: img.title || '',
                    width: img.width || 'unknown',
                    height: img.height || 'unknown'
                }))
                .filter(img => img && img.src);
            
            return images || [];
        }

        function extractStructure(doc) {
            try {
                const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6'))
                    .map(heading => ({
                        level: parseInt(heading.tagName.charAt(1)),
                        text: (heading.textContent || '').trim(),
                        id: heading.id || ''
                    }));

                const lists = Array.from(doc.querySelectorAll('ul, ol'))
                    .map(list => ({
                        type: list.tagName.toLowerCase(),
                        items: Array.from(list.querySelectorAll('li')).map(li => (li.textContent || '').trim())
                    }));

                return {
                    headings: headings || [],
                    lists: lists || [],
                    wordCount: (doc.body.textContent || '').split(/\s+/).length,
                    elementCount: doc.querySelectorAll('*').length || 0
                };
            } catch (error) {
                console.warn('Error extracting structure:', error);
                return {
                    headings: [],
                    lists: [],
                    wordCount: 0,
                    elementCount: 0
                };
            }
        }

        function cleanTextContent(element) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let text = '';
            let node;
            while (node = walker.nextNode()) {
                const parent = node.parentElement;
                if (parent && !['script', 'style'].includes(parent.tagName.toLowerCase())) {
                    text += node.textContent + ' ';
                }
            }

            return text
                .replace(/\s+/g, ' ')
                .replace(/\n\s*\n/g, '\n\n')
                .trim();
        }

        function getMetaContent(doc, name, attribute = 'name') {
            const meta = doc.querySelector(`meta[${attribute}="${name}"]`);
            return meta ? meta.content : '';
        }

        function getCanonicalUrl(doc) {
            const canonical = doc.querySelector('link[rel="canonical"]');
            return canonical ? canonical.href : '';
        }

        function formatForLLM(data) {
            let formatted = `# Web Page Content Analysis\n\n`;
            formatted += `**URL:** ${data.url}\n`;
            formatted += `**Extracted:** ${data.timestamp}\n`;
            formatted += `**Method:** ${data.extractionMethod || 'direct'}\n\n`;
            
            if (data.metadata && Object.keys(data.metadata).length > 0) {
                formatted += `## Metadata\n\n`;
                Object.entries(data.metadata).forEach(([key, value]) => {
                    if (typeof value === 'object') {
                        formatted += `**${key}:**\n`;
                        Object.entries(value).forEach(([subKey, subValue]) => {
                            formatted += `  - ${subKey}: ${subValue}\n`;
                        });
                    } else {
                        formatted += `**${key}:** ${value}\n`;
                    }
                });
                formatted += '\n';
            }

            formatted += `## Main Content\n\n${data.content}\n\n`;

            if (data.structure) {
                formatted += `## Structure Analysis\n\n`;
                formatted += `- **Word Count:** ${data.structure.wordCount}\n`;
                formatted += `- **Element Count:** ${data.structure.elementCount}\n`;
                
                if (data.structure.headings.length > 0) {
                    formatted += `\n### Headings\n\n`;
                    data.structure.headings.forEach(heading => {
                        const indent = '  '.repeat(heading.level - 1);
                        formatted += `${indent}- ${heading.text}\n`;
                    });
                }
            }

            if (data.links && data.links.length > 0) {
                formatted += `\n## Links (${data.links.length})\n\n`;
                data.links.slice(0, 20).forEach((link, i) => {
                    formatted += `${i + 1}. ${link.text} - ${link.href}\n`;
                });
                if (data.links.length > 20) {
                    formatted += `... and ${data.links.length - 20} more links\n`;
                }
            }

            if (data.images && data.images.length > 0) {
                formatted += `\n## Images (${data.images.length})\n\n`;
                data.images.slice(0, 10).forEach((img, i) => {
                    formatted += `${i + 1}. ${img.alt || 'No alt text'} - ${img.src}\n`;
                });
                if (data.images.length > 10) {
                    formatted += `... and ${data.images.length - 10} more images\n`;
                }
            }

            // Add extraction notes
            if (data.extractionMethod) {
                formatted += `\n## Extraction Notes\n\n`;
                switch (data.extractionMethod) {
                    case 'playwright':
                        formatted += `Content rendered with a Playwright-controlled browser to execute JavaScript before extraction.\n`;
                        break;
                    case 'playwright-fallback':
                        formatted += `Playwright rendering was attempted but unavailable. Fallback text-only services were used; dynamic content may be missing.\n`;
                        break;
                    case 'cached':
                        formatted += `Content retrieved from a cached copy (Google Webcache/Wayback). It may differ from the live page.\n`;
                        break;
                    case 'alternative':
                        formatted += `This page requires JavaScript to load properly. Content was extracted using alternative methods.\n`;
                        formatted += `Some dynamic content may be missing. For complete content, consider:\n`;
                        formatted += `- Enabling JavaScript in your browser\n`;
                        formatted += `- Using a browser automation tool\n`;
                        formatted += `- Accessing the page directly\n`;
                        break;
                    default:
                        formatted += `Extraction method: ${data.extractionMethod}.\n`;
                }
            }

            return formatted;
        }

        function convertToMarkdown(data) {
            let markdown = `# ${data.metadata.title || 'Untitled Page'}\n\n`;
            
            if (data.metadata.description) {
                markdown += `> ${data.metadata.description}\n\n`;
            }

            markdown += `**URL:** ${data.url}\n\n`;
            markdown += `---\n\n`;

            // Convert content to basic markdown
            const content = data.content
                .replace(/\n\n+/g, '\n\n')
                .replace(/^([A-Z][^.!?]*[.!?])$/gm, '$1\n\n');
            
            markdown += content;

            return markdown;
        }

function getExtractionDataByIndex(index) {
    if (typeof index === 'number' && index >= 0 && index < extractionHistory.length) {
        return extractionHistory[index];
    }
    return extractedData;
}

async function copyLlmResponse(container) {
    const contentEl = container?.querySelector('.assistant-llm');
    if (!contentEl) {
        showWarning('Nothing to copy from the LLM response.');
        return;
    }

    const text = contentEl.innerText.trim();
    if (!text) {
        showWarning('LLM response is empty, nothing to copy.');
        return;
    }

    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
        } else {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
        showSuccess('LLM response copied to clipboard!');
    } catch (error) {
        console.error('Failed to copy LLM response:', error);
        showError('Could not copy the LLM response. Please copy it manually.');
    }
}

async function copyUserMessage(container) {
    const contentEl = container?.querySelector('.bubble-text');
    if (!contentEl) {
        showWarning('Nothing to copy from the instruction.');
        return;
    }

    const text = contentEl.innerText.trim();
    if (!text) {
        showWarning('Instruction is empty, nothing to copy.');
        return;
    }

    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
        } else {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
        showSuccess('Instruction copied to clipboard!');
    } catch (error) {
        console.error('Failed to copy instruction:', error);
        showError('Could not copy the instruction. Please copy it manually.');
    }
}

async function copyExtractionContent(format, extractionIndex) {
    const data = getExtractionDataByIndex(extractionIndex);
    if (!data) {
        showError('No content to copy');
                return;
            }

            let content = '';
            let label = '';

            switch (format) {
                case 'main': {
                    const mainContent = data.content || '';
                    if (!mainContent.trim()) {
                        showWarning('Main content is empty, nothing to copy.');
                        return;
                    }
                    content = mainContent;
                    label = 'Main content';
                    break;
                }
                case 'txt':
                    content = formatForLLM(data);
                    label = 'Text';
                    break;
                case 'md':
                    content = convertToMarkdown(data);
                    label = 'Markdown';
                    break;
                case 'json':
                    content = JSON.stringify(data, null, 2);
                    label = 'JSON';
                    break;
                case 'html': {
                    const safeTitle = escapeHtml(data.metadata?.title || 'Extracted Content');
                    const safeBody = escapeHtml(formatForLLM(data) || '');
                    content = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${safeTitle}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 5px; }
        pre { background: #f5f5f5; padding: 3.75px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>${safeTitle}</h1>
    <pre>${safeBody}</pre>
</body>
</html>`;
                    label = 'HTML';
                    break;
                }
                default:
                    showError('Unsupported copy format requested.');
                    return;
            }

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(content);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = content;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }
                showSuccess(`${label} copied to clipboard!`);
            } catch (error) {
                console.error('Clipboard copy failed:', error);
                showError(`Failed to copy ${label.toLowerCase()} content. Please copy manually.`);
            }
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        function showProgress() {
            document.getElementById('progressSection').style.display = 'block';
        }

        function hideProgress() {
            document.getElementById('progressSection').style.display = 'none';
        }

        function setProgress(percent, status) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('statusText').textContent = status;
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = `❌ ${message}`;
            errorElement.style.display = 'block';
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 5000);
        }

        function showSuccess(message) {
            const successElement = document.getElementById('successMessage');
            successElement.textContent = `✅ ${message}`;
            successElement.style.display = 'block';
            setTimeout(() => {
                successElement.style.display = 'none';
            }, 3000);
        }

        function showWarning(message) {
            const warningElement = document.getElementById('warningMessage');
            warningElement.innerHTML = `⚠️ ${message}`;
            warningElement.style.display = 'block';
            setTimeout(() => {
                warningElement.style.display = 'none';
            }, 8000);
        }

        function hideMessages() {
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
            document.getElementById('warningMessage').style.display = 'none';
            document.getElementById('extractionMethod').style.display = 'none';
        }
    </script>
</body>
</html>
