<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Content Extractor for LLM Processing</title>
    <link rel="icon" type="image/svg+xml" href="static/favicon.svg">
    <link rel="icon" type="image/png" href="static/favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .input-section {
            background: #f7fafc;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e2e8f0;
        }

        .input-group {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: flex-start;
        }

        .toggle-panel {
            width: 100%;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }

        .toggle-panel:not(.collapsed) {
            box-shadow: 0 12px 30px rgba(79, 209, 197, 0.18);
        }

        .toggle-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 16px 18px;
            background: #edf2f7;
            cursor: pointer;
            font-weight: 600;
            color: #4a5568;
        }

        .toggle-section {
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .toggle-section.collapsed {
            display: none;
        }

        .toggle-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toggle-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.12);
            color: #4c51bf;
            font-size: 14px;
        }

        .action-column {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .task-input {
            flex: 1;
            padding: 15px;
            border: 2px solid #cbd5e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            resize: vertical;
            min-height: 120px;
        }

        .task-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .process-button {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            width: 100%;
        }

        .process-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .process-button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .option-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-group label {
            font-weight: 500;
            color: #4a5568;
        }

        .option-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #667eea;
        }

        .option-group input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #cbd5e0;
            border-radius: 5px;
            font-size: 14px;
        }

        .option-group input[type="url"] {
            flex: 1;
            min-width: 200px;
            padding: 10px;
            border: 2px solid #cbd5e0;
            border-radius: 5px;
            font-size: 14px;
        }

        .option-group.option-group-wide {
            flex-direction: column;
            align-items: flex-start;
        }

        .option-group.option-group-wide input[type="url"] {
            width: 100%;
        }

        .progress-section {
            display: none;
            background: #f7fafc;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e2e8f0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .status-text {
            text-align: center;
            color: #4a5568;
            font-weight: 500;
        }

        .assistant-extraction {
            margin-top: 18px;
            border: 1px solid rgba(203, 213, 225, 0.8);
            border-radius: 14px;
            background: rgba(237, 242, 247, 0.9);
            overflow: hidden;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .assistant-extraction-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 16px;
            background: #ffffff;
            border: 1px solid #a3bffa;
            border-radius: 12px;
            font-weight: 600;
            color: #2d3748;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .assistant-extraction-toggle:hover {
            background: rgba(102, 126, 234, 0.12);
            border-color: #667eea;
        }

        .assistant-extraction-meta {
            font-size: 14px;
            color: #4a5568;
            padding: 6px 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 999px;
        }

        .assistant-extraction-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .assistant-extraction-icon {
            font-size: 14px;
            color: #4c51bf;
        }

        .assistant-extraction-body {
            display: none;
            padding: 14px 16px;
            border-top: 1px solid rgba(203, 213, 225, 0.6);
            background: rgba(247, 250, 252, 0.94);
        }

        .assistant-extraction.open .assistant-extraction-body {
            display: block;
        }

        .assistant-extraction-meta {
            font-size: 13px;
            color: #4a5568;
            margin-bottom: 12px;
        }

        .assistant-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 4px;
        }

        .assistant-tab-button {
            padding: 10px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: #718096;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .assistant-tab-button.active {
            color: #4c51bf;
            border-bottom-color: #4c51bf;
        }

        .assistant-tab-content {
            display: none;
        }

        .assistant-tab-content.active {
            display: block;
        }

        .assistant-content-preview {
            background: white;
            padding: 14px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            max-height: 320px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.45;
        }

        .assistant-preview-header,
        .assistant-downloads {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 18px;
            align-items: center;
            justify-content: flex-end;
        }

        .assistant-preview-header {
            margin-top: 0;
        }

        .assistant-download-button {
            padding: 10px 18px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .assistant-download-button.copy-main {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: #ffffff;
        }

        .assistant-download-button.copy-main:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(66, 153, 225, 0.35);
        }

        .assistant-download-button.secondary {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: #ffffff;
        }

        .assistant-download-button.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.35);
        }

        .assistant-download-button.tertiary {
            background: rgba(76, 81, 191, 0.1);
            color: #4c51bf;
            border: 1px solid rgba(76, 81, 191, 0.2);
            padding: 8px 14px;
        }

        .assistant-download-button.tertiary:hover {
            background: rgba(76, 81, 191, 0.18);
            border-color: rgba(76, 81, 191, 0.45);
        }

        .conversation {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            margin: 25px 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: 420px;
            overflow-y: auto;
        }

        .conversation-message {
            display: flex;
            gap: 12px;
        }

        .conversation-message.user {
            justify-content: flex-end;
        }

        .conversation-message.status .conversation-bubble {
            background: #edf2f7;
            border-color: #cbd5e0;
            color: #2d3748;
            font-weight: 500;
        }

        .conversation-message.status.status-info .conversation-bubble {
            background: #ebf8ff;
            border-color: #bee3f8;
            color: #2b6cb0;
        }

        .conversation-message.status.status-success .conversation-bubble {
            background: #f0fff4;
            border-color: #c6f6d5;
            color: #2f855a;
        }

        .conversation-message.status.status-warning .conversation-bubble {
            background: #fefcbf;
            border-color: #faf089;
            color: #b7791f;
        }

        .conversation-message.status.status-error .conversation-bubble {
            background: #fed7d7;
            border-color: #feb2b2;
            color: #c53030;
        }

        .conversation-bubble {
            max-width: 80%;
            border-radius: 14px;
            padding: 12px 16px;
            background: #edf2f7;
            border: 1px solid #cbd5e0;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .assistant-llm-container {
            position: relative;
        }

        .assistant-llm-copy,
        .user-copy {
            position: absolute;
            top: 6px;
            right: 6px;
            padding: 4px 9px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 999px;
            border: 1px solid rgba(76, 81, 191, 0.3);
            background: rgba(76, 81, 191, 0.12);
            color: #4c51bf;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }

        .assistant-llm-copy:hover,
        .user-copy:hover {
            background: rgba(76, 81, 191, 0.2);
            border-color: rgba(76, 81, 191, 0.5);
            transform: translateY(-1px);
        }

        .assistant-llm {
            white-space: normal;
            padding-right: 48px;
            padding-top: 6px;
        }

        .user-message-body {
            position: relative;
            padding-right: 44px;
        }

        .assistant-llm > * {
            margin-top: 0.6rem;
            margin-bottom: 0.6rem;
        }

        .assistant-llm > *:first-child {
            margin-top: 0;
        }

        .assistant-llm > *:last-child {
            margin-bottom: 0;
        }

        .assistant-llm h1,
        .assistant-llm h2,
        .assistant-llm h3,
        .assistant-llm h4,
        .assistant-llm h5,
        .assistant-llm h6 {
            line-height: 1.25;
        }

        .assistant-llm ul,
        .assistant-llm ol {
            padding-left: 1.5rem;
        }

        .conversation-message.user .conversation-bubble {
            background: #4c51bf;
            color: #ffffff;
            border-color: #434190;
        }

        .conversation-bubble pre {
            background: transparent;
            border: none;
            white-space: pre-wrap;
            margin: 0;
            font-family: inherit;
        }

        .status-message-text {
            font-size: 14px;
            line-height: 1.45;
            white-space: pre-wrap;
        }

        .assistant-loading-inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .assistant-loading-inline .dot {
            width: 8px;
            height: 8px;
            background: #4c51bf;
            border-radius: 50%;
            animation: pulse 1.5s infinite ease-in-out;
        }

        .assistant-loading-inline .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .assistant-loading-inline .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 80%, 100% { opacity: 0.2; transform: scale(0.8); }
            40% { opacity: 1; transform: scale(1); }
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #fc8181;
            margin-bottom: 20px;
            display: none;
        }

        .success-message {
            background: #c6f6d5;
            color: #276749;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #9ae6b4;
            margin-bottom: 20px;
            display: none;
        }

        .warning-message {
            background: #fef5e7;
            color: #d69e2e;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #fbd38d;
            margin-bottom: 20px;
            display: none;
        }

        .extraction-method {
            background: #e6fffa;
            color: #0077b6;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #81e6d9;
            margin-bottom: 20px;
            display: none;
            font-size: 14px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .input-group {
                flex-direction: column;
            }

            .action-column {
                width: 100%;
            }
            
            .options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌐 Web Content Extractor</h1>
        <p class="subtitle">Paste an instruction with a URL. The app fetches the page and pushes it through your Ollama model automatically.</p>

        <div class="error-message" id="errorMessage"></div>
        <div class="warning-message" id="warningMessage"></div>
        <div class="success-message" id="successMessage"></div>
        <div class="extraction-method" id="extractionMethod"></div>

        <div class="conversation" id="chatMessages"></div>

        <div class="input-section">
            <label class="input-label" for="taskInput">Instruction &amp; URL</label>
            <div class="input-group">
                <textarea
                    class="task-input"
                    id="taskInput"
                    placeholder=""></textarea>
                <div class="action-column">
                    <button class="process-button" id="processButton" onclick="runTask()">
                        Run Task
                    </button>
                    <div class="toggle-panel collapsed" id="optionsPanel">
                        <div class="toggle-title collapsed" id="optionsToggle">
                            <span>Extraction &amp; Server Options</span>
                            <span class="toggle-icon" id="optionsToggleIcon">▸</span>
                        </div>
                        <div class="toggle-section collapsed" id="optionsToggleContent">
                            <div class="toggle-grid">
                                <label class="option-group">
                                    <input type="checkbox" id="includeImages" checked>
                                    <span>Include Image Alt Text</span>
                                </label>
                                <label class="option-group">
                                    <input type="checkbox" id="includeLinks" checked>
                                    <span>Include Link Text</span>
                                </label>
                                <label class="option-group">
                                    <input type="checkbox" id="includeMetadata" checked>
                                    <span>Include Page Metadata</span>
                                </label>
                                <label class="option-group">
                                    <input type="checkbox" id="expandDynamic" checked>
                                    <span>Expand Dynamic Content</span>
                                </label>
                                <label class="option-group">
                                    <input type="checkbox" id="cleanContent" checked>
                                    <span>Clean &amp; Format Content</span>
                                </label>
                            </div>
                            <div class="toggle-grid">
                                <label class="option-group option-group-wide">
                                    <span>Playwright Server URL</span>
                                    <input type="url" id="playwrightServer" value="http://localhost:3050" placeholder="http://localhost:3050">
                                </label>
                                <label class="option-group">
                                    <span>Wait Time (ms)</span>
                                    <input type="number" id="waitTime" value="3000" min="1000" max="10000" step="500">
                                </label>
                                <label class="option-group option-group-wide">
                                    <span>Ollama Server URL</span>
                                    <input type="url" id="ollamaServer" class="llm-input" placeholder="http://localhost:11434">
                                </label>
                                <label class="option-group option-group-wide">
                                    <span>Ollama Model</span>
                                    <div class="llm-model-row">
                                        <select id="ollamaModel" class="llm-select">
                                            <option value="" disabled selected>Loading models...</option>
                                        </select>
                                        <button class="llm-refresh-button" type="button" onclick="loadOllamaModels(true)">↻ Refresh</button>
                                    </div>
                                </label>
                                <div class="llm-format-toggle">
                                    <label>
                                        <input type="radio" name="llmPayloadFormat" value="markdown" checked>
                                        Markdown
                                    </label>
                                    <label>
                                        <input type="radio" name="llmPayloadFormat" value="json">
                                        JSON
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status-text" id="statusText">Initializing...</div>
        </div>
    </div>

    <script>
let extractedData = null;
const extractionHistory = [];
const PLAYWRIGHT_STORAGE_KEY = 'playwrightServerUrl';
const OLLAMA_SERVER_STORAGE_KEY = 'ollamaServerUrl';
const OLLAMA_MODEL_STORAGE_KEY = 'ollamaModel';
const PREFERRED_OLLAMA_MODEL = 'gpt-oss:120b-cloud';
const DEFAULT_OLLAMA_MODELS = [
    PREFERRED_OLLAMA_MODEL,
    'llama3.1:latest',
    'llama3',
    'mistral',
    'mixtral',
    'phi3'
];
const LLM_RESPONSE_FORMAT_HINT = [
    'Format your entire response as semantic HTML that renders cleanly in a browser.',
    'Use headings (<h2>, <h3>), paragraphs, bullet lists, numbered lists, tables, and short sections where helpful.',
    'Wrap code samples in <pre><code>...</code></pre> blocks.',
    'Avoid including <script>, <iframe>, <object>, <embed>, <html>, <head>, or <body> tags.'
].join(' ');

function escapeHtml(value) {
    return value.replace(/[&<>"']/g, function(char) {
        switch (char) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            case "'": return '&#39;';
            default: return char;
        }
    });
}

const conversationEl = document.getElementById('chatMessages');
let pendingAssistantMessage = null;
let statusMessageEl = null;

function appendConversationMessage(role, html) {
    if (!conversationEl) return null;
    const wrapper = document.createElement('div');
    wrapper.className = `conversation-message ${role}`;
    const bubble = document.createElement('div');
    bubble.className = 'conversation-bubble';
    bubble.innerHTML = html;
    wrapper.appendChild(bubble);
    conversationEl.appendChild(wrapper);
    requestAnimationFrame(scrollConversationToEnd);
    return wrapper;
}

function updateConversationMessage(messageEl, html) {
    if (!messageEl) return;
    const bubble = messageEl.querySelector('.conversation-bubble');
    if (bubble) {
        bubble.innerHTML = html;
        requestAnimationFrame(scrollConversationToEnd);
    }
}

function renderUserMessage(text) {
    return `
        <div class="user-message-body" data-user-message>
            <button type="button" class="assistant-llm-copy user-copy" data-copy-user>
                <span>📋</span>
                <span>Copy</span>
            </button>
            <pre>${escapeHtml(text)}</pre>
        </div>
    `;
}

function renderAssistantLoading(text = 'Working…') {
    return `<span class="assistant-loading-inline"><span class="dot"></span><span class="dot"></span><span class="dot"></span><span>${escapeHtml(text)}</span></span>`;
}

function renderAssistantResponse(llmHtml, data, extractionIndex) {
    const detailsHtml = data ? renderExtractionDetails(data, extractionIndex) : '';
    return `
        <div class="assistant-llm-container">
            <button type="button" class="assistant-llm-copy" data-copy-llm>
                <span>📋</span>
                <span>Copy</span>
            </button>
            <div class="assistant-llm">${llmHtml}</div>
        </div>
        ${detailsHtml}
    `;
}

function renderExtractionDetails(data, extractionIndex) {
    if (!data) {
        return '';
    }

    const detailId = `details-${Date.now().toString(36)}-${Math.floor(Math.random() * 1e6)}`;
    const formattedOutline = escapeHtml((formatForLLM(data) || '').trim());
    const structuredJson = escapeHtml(JSON.stringify(data.structure ?? {}, null, 2));
    const markdown = escapeHtml((convertToMarkdown(data) || '').trim());
    const rawJson = escapeHtml(JSON.stringify(data, null, 2));
    const methodLabel = data.extractionMethod ? `<div class="assistant-extraction-meta">Method: ${escapeHtml(data.extractionMethod)}</div>` : '';
    const indexAttr = typeof extractionIndex === 'number' ? ` data-extraction-index="${extractionIndex}"` : '';

    return `
        <div class="assistant-extraction"${indexAttr}>
            <div class="assistant-extraction-header">
                ${methodLabel}
                <button class="assistant-extraction-toggle" type="button" data-target="${detailId}">
                    <span>Extraction Details</span>
                    <span class="assistant-extraction-icon">▸</span>
                </button>
            </div>
            <div class="assistant-extraction-body" id="${detailId}">
                <div class="assistant-tabs" role="tablist">
                    <button type="button" class="assistant-tab-button active" data-tab="outline">Formatted Text</button>
                    <button type="button" class="assistant-tab-button" data-tab="structured">Structured Data</button>
                    <button type="button" class="assistant-tab-button" data-tab="markdown">Markdown</button>
                    <button type="button" class="assistant-tab-button" data-tab="json">Full JSON</button>
                </div>
                <div class="assistant-tab-content active" data-tab="outline">
                    <div class="assistant-preview-header">
                        <button type="button" class="assistant-download-button tertiary" data-copy-format="outline" data-copy-label="Formatted Text">
                            📋 Copy
                        </button>
                    </div>
                    <pre class="assistant-content-preview">${formattedOutline}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="structured">
                    <pre class="assistant-content-preview">${structuredJson}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="markdown">
                    <pre class="assistant-content-preview">${markdown}</pre>
                </div>
                <div class="assistant-tab-content" data-tab="json">
                    <pre class="assistant-content-preview">${rawJson}</pre>
                </div>
                <div class="assistant-downloads">
                    <button type="button" class="assistant-download-button copy-main" data-copy-format="main">
                        📋 Copy Main Content
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="txt">
                        📄 Copy Text
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="md">
                        📝 Copy Markdown
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="json">
                        📊 Copy JSON
                    </button>
                    <button type="button" class="assistant-download-button secondary" data-copy-format="html">
                        🌐 Copy HTML
                    </button>
                </div>
            </div>
        </div>
    `;
}

function sanitizePreformattedHtml(value) {
    return value
        .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '')
        .replace(/\son\w+\s*=\s*(["']).*?\1/gi, '')
        .replace(/href\s*=\s*(["'])\s*javascript:[^"']*\1/gi, 'href="#"')
        .replace(/src\s*=\s*(["'])\s*javascript:[^"']*\1/gi, '');
}

function escapeAttribute(value) {
    return escapeHtml(value).replace(/"/g, '&quot;');
}

function sanitizeLinkUrl(url) {
    const trimmed = url.trim();
    if (/^(https?:|mailto:|tel:)/i.test(trimmed)) {
        return trimmed;
    }
    return '';
}

function applyInlineFormatting(text) {
    const replacements = [];
    let working = text;

    const registerReplacement = (html, label) => {
        const token = `@@__${label}_${replacements.length}__@@`;
        replacements.push({ token, html });
        return token;
    };

    working = working.replace(/`([^`]+)`/g, (_, code) => registerReplacement(`<code>${escapeHtml(code)}</code>`, 'CODE'));

    working = working.replace(/\*\*([^*]+)\*\*/g, (_, content) => registerReplacement(`<strong>${escapeHtml(content)}</strong>`, 'BOLD'));
    working = working.replace(/__([^_]+)__/g, (_, content) => registerReplacement(`<strong>${escapeHtml(content)}</strong>`, 'BOLD'));

    working = working.replace(/~~([^~]+)~~/g, (_, content) => registerReplacement(`<del>${escapeHtml(content)}</del>`, 'DEL'));

    working = working.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_, label, url) => {
        const safeUrl = sanitizeLinkUrl(url);
        if (!safeUrl) {
            return registerReplacement(escapeHtml(`[${label}](${url})`), 'TEXT');
        }
        return registerReplacement(
            `<a href="${escapeAttribute(safeUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(label)}</a>`,
            'LINK'
        );
    });

    working = working.replace(/\*([^*]+)\*/g, (_, content) => registerReplacement(`<em>${escapeHtml(content)}</em>`, 'EM'));
    working = working.replace(/_([^_]+)_/g, (_, content) => registerReplacement(`<em>${escapeHtml(content)}</em>`, 'EM'));

    let escaped = escapeHtml(working);
    for (const { token, html } of replacements) {
        escaped = escaped.split(token).join(html);
    }
    return escaped;
}

function convertMarkdownToHtml(markdown) {
    const lines = markdown.replace(/\r\n/g, '\n').split('\n');
    const html = [];
    let inUl = false;
    let inOl = false;
    let inCode = false;
    let codeLang = '';
    let codeLines = [];
    let paragraphLines = [];

    const closeLists = () => {
        if (inUl) {
            html.push('</ul>');
            inUl = false;
        }
        if (inOl) {
            html.push('</ol>');
            inOl = false;
        }
    };

    const flushParagraph = () => {
        if (!paragraphLines.length) {
            return;
        }
        const content = paragraphLines.join('\n');
        const formatted = applyInlineFormatting(content).replace(/\n/g, '<br>');
        html.push(`<p>${formatted}</p>`);
        paragraphLines = [];
    };

    const flushCodeBlock = () => {
        if (!inCode) {
            return;
        }
        const codeContent = codeLines.join('\n');
        const langAttr = codeLang ? ` class="language-${escapeHtml(codeLang)}"` : '';
        html.push(`<pre><code${langAttr}>${escapeHtml(codeContent)}</code></pre>`);
        inCode = false;
        codeLang = '';
        codeLines = [];
    };

    for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, '    ');
        const trimmed = line.trim();

        if (inCode) {
            if (/^```/.test(trimmed)) {
                flushCodeBlock();
            } else {
                codeLines.push(line);
            }
            continue;
        }

        if (!trimmed) {
            flushParagraph();
            closeLists();
            continue;
        }

        const codeStart = trimmed.match(/^```(\w+)?/);
        if (codeStart) {
            flushParagraph();
            closeLists();
            inCode = true;
            codeLang = codeStart[1] || '';
            continue;
        }

        const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
        if (headingMatch) {
            flushParagraph();
            closeLists();
            const level = headingMatch[1].length;
            html.push(`<h${level}>${applyInlineFormatting(headingMatch[2])}</h${level}>`);
            continue;
        }

        if (/^>\s?/.test(trimmed)) {
            flushParagraph();
            closeLists();
            const quote = trimmed.replace(/^>\s?/, '');
            html.push(`<blockquote>${applyInlineFormatting(quote)}</blockquote>`);
            continue;
        }

        if (/^([-*_])\s*\1\s*\1\s*$/.test(trimmed)) {
            flushParagraph();
            closeLists();
            html.push('<hr>');
            continue;
        }

        const olMatch = trimmed.match(/^(\d+)[.)]\s+(.*)$/);
        if (olMatch) {
            flushParagraph();
            if (!inOl) {
                closeLists();
                html.push('<ol>');
                inOl = true;
            }
            html.push(`<li>${applyInlineFormatting(olMatch[2])}</li>`);
            continue;
        }

        const ulMatch = trimmed.match(/^[-*+]\s+(.*)$/);
        if (ulMatch) {
            flushParagraph();
            if (!inUl) {
                closeLists();
                html.push('<ul>');
                inUl = true;
            }
            html.push(`<li>${applyInlineFormatting(ulMatch[1])}</li>`);
            continue;
        }

        paragraphLines.push(line);
    }

    flushParagraph();
    flushCodeBlock();
    closeLists();

    if (!html.length) {
        return `<p>${escapeHtml(markdown)}</p>`;
    }

    return html.join('');
}

function renderLlmOutput(message) {
    if (typeof message !== 'string') {
        return '<em>(Unexpected LLM response format.)</em>';
    }

    const trimmed = message.trim();
    if (!trimmed) {
        return '<em>(LLM returned an empty response.)</em>';
    }

    const sanitized = sanitizePreformattedHtml(trimmed);
    if (/<\/?[a-z][\s\S]*>/i.test(sanitized)) {
        return sanitized;
    }

    return convertMarkdownToHtml(sanitized);
}

function scrollConversationToEnd() {
    if (conversationEl) {
        conversationEl.scrollTop = conversationEl.scrollHeight;
    }
}

(function restorePlaywrightServerSetting() {
    const input = document.getElementById('playwrightServer');
    if (!input) return;
    try {
        const saved = localStorage.getItem(PLAYWRIGHT_STORAGE_KEY);
        if (saved) {
            input.value = saved;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Playwright server URL:', storageError);
    }
    input.addEventListener('change', () => {
        try {
            localStorage.setItem(PLAYWRIGHT_STORAGE_KEY, input.value.trim());
        } catch (storageError) {
            console.warn('Unable to persist Playwright server URL:', storageError);
        }
    });
})();

(function restoreOllamaSettings() {
    const serverInput = document.getElementById('ollamaServer');
    const modelSelect = document.getElementById('ollamaModel');
    if (!serverInput || !modelSelect) return;

    let storedServerUrl = 'http://localhost:11434';
    try {
        const saved = localStorage.getItem(OLLAMA_SERVER_STORAGE_KEY);
        if (saved) {
            storedServerUrl = saved;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Ollama server URL:', storageError);
    }
    serverInput.value = normalizeOllamaBaseUrl(storedServerUrl);

    serverInput.addEventListener('change', () => {
        const normalized = normalizeOllamaBaseUrl(serverInput.value);
        serverInput.value = normalized;
        try {
            localStorage.setItem(OLLAMA_SERVER_STORAGE_KEY, normalized);
        } catch (storageError) {
            console.warn('Unable to persist Ollama server URL:', storageError);
        }
        loadOllamaModels(true);
    });

    try {
        const savedModel = localStorage.getItem(OLLAMA_MODEL_STORAGE_KEY);
        if (savedModel) {
            modelSelect.dataset.preferredModel = savedModel;
        }
    } catch (storageError) {
        console.warn('Unable to access localStorage for Ollama model preference:', storageError);
    }

    loadOllamaModels();

    modelSelect.addEventListener('change', () => {
        try {
            localStorage.setItem(OLLAMA_MODEL_STORAGE_KEY, modelSelect.value);
        } catch (storageError) {
            console.warn('Unable to persist Ollama model preference:', storageError);
        }
        updateLlmSendAvailability();
    });
})();

(function setupOptionsToggle() {
    const toggle = document.getElementById('optionsToggle');
    const content = document.getElementById('optionsToggleContent');
    const icon = document.getElementById('optionsToggleIcon');
    const panel = document.getElementById('optionsPanel');
    if (!toggle || !content || !icon || !panel) {
        return;
    }

    function applyState(collapsed) {
        content.classList.toggle('collapsed', collapsed);
        toggle.classList.toggle('collapsed', collapsed);
        panel.classList.toggle('collapsed', collapsed);
        icon.textContent = collapsed ? '▸' : '▾';
    }

    applyState(true);

    toggle.addEventListener('click', () => {
        applyState(!content.classList.contains('collapsed'));
    });
})();

if (conversationEl) {
    conversationEl.addEventListener('click', event => {
        const copyLlmButton = event.target.closest('[data-copy-llm]');
        if (copyLlmButton) {
            const container = copyLlmButton.closest('.assistant-llm-container');
            if (container) {
                copyLlmResponse(container);
            }
            return;
        }

        const copyUserButton = event.target.closest('[data-copy-user]');
        if (copyUserButton) {
            const container = copyUserButton.closest('.user-message-body');
            if (container) {
                copyUserMessage(container);
            }
            return;
        }

        const toggleButton = event.target.closest('.assistant-extraction-toggle');
        if (toggleButton) {
            const container = toggleButton.closest('.assistant-extraction');
            if (container) {
                const isOpen = container.classList.toggle('open');
                const icon = toggleButton.querySelector('.assistant-extraction-icon');
                if (icon) {
                    icon.textContent = isOpen ? '▾' : '▸';
                }
            }
            return;
        }

        const tabButton = event.target.closest('.assistant-tab-button');
        if (tabButton) {
            const body = tabButton.closest('.assistant-extraction-body');
            if (!body) {
                return;
            }
            const tabName = tabButton.dataset.tab;
            body.querySelectorAll('.assistant-tab-button').forEach(btn => btn.classList.remove('active'));
            tabButton.classList.add('active');
            body.querySelectorAll('.assistant-tab-content').forEach(panel => {
                panel.classList.toggle('active', panel.dataset.tab === tabName);
            });
            return;
        }

        const copyButton = event.target.closest('.assistant-download-button');
        if (copyButton) {
            const container = copyButton.closest('.assistant-extraction');
            let format = copyButton.dataset.copyFormat;
            if (format === 'outline') {
                format = 'txt';
            }
            const index = container && container.dataset.extractionIndex !== undefined
                ? Number(container.dataset.extractionIndex)
                : undefined;
            copyExtractionContent(format, Number.isFinite(index) ? index : undefined);
        }
    });
}

const taskInputElement = document.getElementById('taskInput');
if (taskInputElement) {
    taskInputElement.addEventListener('keydown', event => {
        if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            runTask();
        }
    });
}

function extractFirstUrl(text) {
    if (!text) return null;
    const match = text.match(/https?:\/\/[^\s"'<>]+/i);
    if (!match) return null;
    return match[0].replace(/["')\],.?!]+$/, '');
}

async function runTask() {
    const instruction = (taskInputElement?.value || '').trim();
    if (!instruction) {
        showError('Please provide an instruction that includes at least one URL.');
        return;
    }

    const targetUrl = extractFirstUrl(instruction);
    if (!targetUrl) {
        showError('Please include at least one valid URL in your instruction.');
        return;
    }

    if (!isValidUrl(targetUrl)) {
        showError('The URL detected in your instruction is not valid. Please double-check it.');
        return;
    }

    appendConversationMessage('user', renderUserMessage(instruction));
    if (taskInputElement) {
        taskInputElement.value = '';
    }
    pendingAssistantMessage = appendConversationMessage('assistant', renderAssistantLoading('Extracting page content...'));

    extractedData = null;
    updateLlmSendAvailability();

    hideMessages();
    showProgress();
    setProgress(0, 'Preparing to extract content...');

    try {
        const content = await extractContent(targetUrl);
        const record = { ...content, instruction };
        const extractionIndex = extractionHistory.push(record) - 1;
        record.extractionIndex = extractionIndex;
        extractedData = record;
        updateLlmSendAvailability();

        const methodElement = document.getElementById('extractionMethod');
        if (methodElement) {
            methodElement.style.display = 'none';
        }

        setProgress(100, 'Extraction complete!');
        hideProgress();
        showSuccess('Content extracted successfully!');

        if (pendingAssistantMessage) {
            updateConversationMessage(pendingAssistantMessage, renderAssistantLoading('Generating LLM response...'));
        }

        const modelSelect = document.getElementById('ollamaModel');
        if (modelSelect && modelSelect.value) {
            setLlmStatus('info', 'Generating response with your Ollama model...');
            await sendToLLM(true, pendingAssistantMessage, extractionIndex);
        } else {
            const placeholder = '<p>Extraction complete. Choose an Ollama model under Settings, then click “Send to Ollama”.</p>';
            updateConversationMessage(pendingAssistantMessage, renderAssistantResponse(placeholder, record, extractionIndex));
            setLlmStatus('warning', 'Extraction ready. Choose an Ollama model and click “Send to Ollama” to continue.');
        }
    } catch (error) {
        setProgress(0, 'Error occurred');
        hideProgress();
        const message = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(pendingAssistantMessage, message);
        showError(`Failed to complete the task: ${error.message}`);
    } finally {
        pendingAssistantMessage = null;
    }
}

async function extractContent(url) {
    const parser = new DOMParser();
    setProgress(25, 'Launching Playwright browser...');

    try {
        const html = await extractWithPlaywright(url);
        if (html && html.length > 0) {
            const doc = parser.parseFromString(html, 'text/html');
            setProgress(70, 'Processing content...');
            return processExtractedContent(url, doc, 'playwright');
        }
    } catch (error) {
        console.warn('Playwright extraction failed:', error);
        showWarning(`Playwright extraction failed: ${error.message}`);
    }

    setProgress(55, 'Falling back to static extraction...');
    try {
        const html = await tryMultipleExtractionMethods(url);
        if (html) {
            const doc = parser.parseFromString(html, 'text/html');
            setProgress(70, 'Processing content...');
            return processExtractedContent(url, doc, 'direct');
        }
    } catch (error) {
        console.warn('Static extraction failed:', error);
    }

    throw new Error('Unable to retrieve content from the URL. Playwright and fallback methods failed.');
}

async function sendToLLM(autoTriggered = false, messageEl = null, extractionIndex = extractedData?.extractionIndex) {
    const currentExtraction = typeof extractionIndex === 'number'
        ? extractionHistory[extractionIndex]
        : extractedData;

    if (!currentExtraction) {
        showError('Extract content before sending anything to the LLM.');
        return;
    }

    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect || !modelSelect.value) {
        showError('Select an Ollama model before sending.');
        return;
    }

    let assistantMessage = messageEl;
    if (!assistantMessage) {
        assistantMessage = appendConversationMessage('assistant', renderAssistantLoading('Generating LLM response...'));
    } else {
        updateConversationMessage(assistantMessage, renderAssistantLoading('Generating LLM response...'));
    }

    const selectedFormat = document.querySelector('input[name="llmPayloadFormat"]:checked')?.value || 'markdown';
    const sendButton = document.getElementById('llmSendButton');

    const formattedContent = selectedFormat === 'json'
        ? JSON.stringify(currentExtraction, null, 2)
        : convertToMarkdown(currentExtraction);

    const basePrompt = currentExtraction.instruction || 'Provide a concise summary of the extracted content.';
    const assembledPrompt = `${basePrompt}

---
Extracted content (${selectedFormat.toUpperCase()}):
${formattedContent}

${LLM_RESPONSE_FORMAT_HINT}`;

    showLlmProgress('Preparing payload...', 15);
    if (!autoTriggered) {
        setLlmStatus('', '');
    }
    if (sendButton) {
        sendButton.disabled = true;
    }

    let baseUrl = 'http://localhost:11434';
    try {
        baseUrl = getOllamaBaseUrl();
    } catch (error) {
        hideLlmProgress();
        setLlmStatus('error', error.message);
        const errorHtml = `<div class="assistant-error">${escapeHtml(error.message)}</div>`;
        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(errorHtml, currentExtraction, extractionIndex)
        );
        if (sendButton) {
            sendButton.disabled = false;
        }
        return;
    }

    try {
        updateLlmProgress(35, `Sending request to ${baseUrl}...`);
        const response = await fetch(`${baseUrl}/api/generate`, {
            method: 'POST',
            mode: 'cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: modelSelect.value,
                prompt: assembledPrompt,
                stream: false
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Ollama responded with ${response.status}: ${errorText}`);
        }

        updateLlmProgress(70, 'Waiting for LLM response...');
        const result = await response.json();
        const message = result?.response || result?.message || '(No response text received.)';
        updateLlmProgress(100, 'LLM response received.');

        const llmHtml = renderLlmOutput(message);
        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(llmHtml, currentExtraction, extractionIndex)
        );
        setLlmStatus('success', `Response generated with ${modelSelect.value}.`);
    } catch (error) {
        console.error('Ollama request failed:', error);
        updateLlmProgress(0, 'LLM request failed.');
        let errorMessage = error?.message || 'Failed to reach Ollama.';
        if (error instanceof TypeError || /Failed to fetch/i.test(errorMessage)) {
            const currentOrigin = window.location.origin || 'file://';
            errorMessage = [
                'Browser blocked the request to Ollama (likely CORS).',
                'Restart Ollama with CORS enabled, for example:',
                '  export OLLAMA_ORIGINS="*"',
                '  ollama serve',
                `or allow the UI origin explicitly: OLLAMA_ORIGINS="${currentOrigin}"`,
                `Attempted endpoint: ${baseUrl}/api/generate`
            ].join('\n');
        }
        setLlmStatus('error', errorMessage);
        const errorHtml = `<div class="assistant-error">${escapeHtml(errorMessage)}</div>`;
        updateConversationMessage(
            assistantMessage,
            renderAssistantResponse(errorHtml, currentExtraction, extractionIndex)
        );
        showError(`LLM request failed: ${errorMessage}`);
    } finally {
        setTimeout(() => hideLlmProgress(), 1500);
        if (sendButton) {
            sendButton.disabled = !(currentExtraction && modelSelect && modelSelect.value);
        }
        updateLlmSendAvailability();
    }
}

function setLlmStatus(type, message) {
    if (!conversationEl) {
        return;
    }

    const trimmedMessage = (message || '').trim();
    if (!trimmedMessage) {
        if (statusMessageEl && conversationEl.contains(statusMessageEl)) {
            conversationEl.removeChild(statusMessageEl);
        }
        statusMessageEl = null;
        return;
    }

    if (!statusMessageEl || !conversationEl.contains(statusMessageEl)) {
        statusMessageEl = appendConversationMessage('assistant status', '');
        if (!statusMessageEl) {
            return;
        }
        statusMessageEl.classList.add('status');
    }

    // Ensure the status message stays at the end of the conversation
    try {
        conversationEl.appendChild(statusMessageEl);
    } catch (error) {
        console.warn('Unable to reposition status message:', error);
    }

    const bubble = statusMessageEl.querySelector('.conversation-bubble');
    if (!bubble) {
        return;
    }

    const safeType = (type || '').toLowerCase();
    statusMessageEl.classList.remove('status-info', 'status-success', 'status-warning', 'status-error');
    if (safeType) {
        statusMessageEl.classList.add(`status-${safeType}`);
    }

    const safeHtml = escapeHtml(trimmedMessage).replace(/\n/g, '<br>');
    bubble.innerHTML = `<div class="status-message-text">${safeHtml}</div>`;
    requestAnimationFrame(scrollConversationToEnd);
}

function showLlmProgress(message, percent = 0) {
    const progressElement = document.getElementById('llmProgress');
    if (!progressElement) {
        return;
    }
    progressElement.style.display = 'block';
    updateLlmProgress(percent, message);
}

function updateLlmProgress(percent, message) {
    const fillElement = document.getElementById('llmProgressFill');
    const statusText = document.getElementById('llmStatusText');
    if (fillElement) {
        const clamped = Math.max(0, Math.min(100, percent));
        fillElement.style.width = `${clamped}%`;
    }
    if (statusText) {
        statusText.textContent = message || '';
    }
}

function hideLlmProgress() {
    const progressElement = document.getElementById('llmProgress');
    if (!progressElement) {
        return;
    }
    progressElement.style.display = 'none';
    updateLlmProgress(0, '');
}

function normalizeOllamaBaseUrl(value) {
    if (!value) {
        return 'http://localhost:11434';
    }
    let trimmed = value.trim();
    if (!/^https?:\/\//i.test(trimmed)) {
        trimmed = `http://${trimmed}`;
    }
    try {
        const parsed = new URL(trimmed);
        return parsed.origin;
    } catch (error) {
        console.warn('Invalid Ollama server URL provided; defaulting to localhost.', error);
        return 'http://localhost:11434';
    }
}

function getOllamaBaseUrl() {
    const input = document.getElementById('ollamaServer');
    if (!input) {
        throw new Error('Ollama server input not found.');
    }
    const normalized = normalizeOllamaBaseUrl(input.value);
    input.value = normalized;
    return normalized;
}

function describeOllamaModel(model) {
    if (!model) {
        return null;
    }

    const primary = (model.model || model.name || model.tag || '').trim();
    if (!primary) {
        return null;
    }

    return { value: primary, label: primary };
}

function buildDefaultModelOptions() {
    return DEFAULT_OLLAMA_MODELS.map(name => ({ value: name, label: name }));
}

function dedupeModelOptions(options) {
    const map = new Map();
    options.forEach(option => {
        if (!option || !option.value) {
            return;
        }
        if (!map.has(option.value)) {
            map.set(option.value, option);
        }
    });
    return Array.from(map.values());
}

function prioritizeModelOptions(options) {
    return options
        .slice()
        .sort((a, b) => {
            if (a.value === PREFERRED_OLLAMA_MODEL) return -1;
            if (b.value === PREFERRED_OLLAMA_MODEL) return 1;
            const aCloud = /cloud/i.test(a.value);
            const bCloud = /cloud/i.test(b.value);
            if (aCloud && !bCloud) return -1;
            if (!aCloud && bCloud) return 1;
            return a.label.localeCompare(b.label);
        });
}

function hasModelOption(options, value) {
    return options.some(option => option.value === value || option.label === value);
}

function formatBytes(value) {
    if (!Number.isFinite(value)) {
        return null;
    }
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let size = value;
    let index = 0;
    while (size >= 1024 && index < units.length - 1) {
        size /= 1024;
        index += 1;
    }
    const precision = size >= 100 || index === 0 ? 0 : 1;
    return `${size.toFixed(precision)} ${units[index]}`;
}

async function pullOllamaModel(baseUrl, modelName, onUpdate) {
    const response = await fetch(`${baseUrl}/api/pull`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: modelName, stream: true })
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText || 'Request failed'}`);
    }

    const processEvent = event => {
        if (!event) {
            return { success: false };
        }
        if (event.error) {
            throw new Error(event.error);
        }
        if (typeof onUpdate === 'function') {
            try {
                onUpdate(event);
            } catch (callbackError) {
                console.warn('Ollama pull status callback error:', callbackError);
            }
        }

        const statusText = (event.status || '').toLowerCase();
        let isSuccess = /success|already exists/.test(statusText);

        const completedValue = Number(event.completed);
        const totalValue = Number(event.total);
        if (!isSuccess && Number.isFinite(completedValue) && Number.isFinite(totalValue) && totalValue > 0) {
            isSuccess = completedValue >= totalValue;
        }

        return { success: isSuccess };
    };

    let pullCompleted = false;

    if (response.body && response.body.getReader) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                break;
            }
            buffer += decoder.decode(value, { stream: true });

            let newlineIndex = buffer.indexOf('\n');
            while (newlineIndex !== -1) {
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                if (line) {
                    try {
                        const event = JSON.parse(line);
                        const { success } = processEvent(event);
                        pullCompleted = pullCompleted || success;
                    } catch (parseError) {
                        console.warn('Failed to parse Ollama pull message:', parseError, line);
                    }
                }
                newlineIndex = buffer.indexOf('\n');
            }
        }

        const remaining = buffer.trim();
        if (remaining) {
            try {
                const event = JSON.parse(remaining);
                const { success } = processEvent(event);
                pullCompleted = pullCompleted || success;
            } catch (parseError) {
                console.warn('Failed to parse final Ollama pull message:', parseError, remaining);
            }
        }
    } else {
        const text = await response.text();
        text.split(/\r?\n/).forEach(line => {
            const trimmed = line.trim();
            if (!trimmed) {
                return;
            }
            try {
                const event = JSON.parse(trimmed);
                const { success } = processEvent(event);
                pullCompleted = pullCompleted || success;
            } catch (parseError) {
                console.warn('Failed to parse Ollama pull message:', parseError, trimmed);
            }
        });
    }

    if (!pullCompleted) {
        throw new Error('Model pull did not complete successfully.');
    }
}

async function ensurePreferredModelAvailable(baseUrl, triggeredByUser) {
    const modelName = PREFERRED_OLLAMA_MODEL;
    setLlmStatus('info', `Default Ollama model missing. Pulling ${modelName}...`);

    const updateStatus = event => {
        if (!event) {
            return;
        }
        const parts = [];
        if (event.status) {
            parts.push(event.status);
        }
        const completedValue = Number(event.completed);
        const totalValue = Number(event.total);
        if (Number.isFinite(completedValue) && Number.isFinite(totalValue) && totalValue > 0) {
            const percent = Math.max(0, Math.min(100, Math.round((completedValue / totalValue) * 100)));
            const completed = formatBytes(completedValue);
            const total = formatBytes(totalValue);
            if (completed && total) {
                parts.push(`${percent}% (${completed} / ${total})`);
            } else {
                parts.push(`${percent}%`);
            }
        } else if (Number.isFinite(completedValue)) {
            const downloaded = formatBytes(completedValue);
            if (downloaded) {
                parts.push(`${downloaded} downloaded`);
            }
        }

        const detail = parts.join(' - ') || 'Working...';
        setLlmStatus('info', `Pulling ${modelName}: ${detail}`);
    };

    try {
        await pullOllamaModel(baseUrl, modelName, updateStatus);
        setLlmStatus('success', `Model ${modelName} is ready to use.`);
        if (triggeredByUser) {
            showSuccess(`Ollama model ${modelName} pulled successfully.`);
        }
        return true;
    } catch (error) {
        console.error('Failed to pull preferred Ollama model:', error);
        setLlmStatus('error', `Unable to pull ${modelName}: ${error.message}`);
        if (triggeredByUser) {
            showError(`Failed to pull ${modelName}: ${error.message}`);
        }
        return false;
    }
}

async function loadOllamaModels(triggeredByUser = false, skipEnsurePreferred = false) {
    const modelSelect = document.getElementById('ollamaModel');
    if (!modelSelect) {
        return;
    }

    const sendButton = document.getElementById('llmSendButton');
    if (sendButton) {
        sendButton.disabled = true;
    }

    if (triggeredByUser) {
        setLlmStatus('info', 'Refreshing model list from Ollama...');
    }

    let models = [];
    let baseUrl = '';
    try {
        baseUrl = getOllamaBaseUrl();
        if (triggeredByUser) {
            setLlmStatus('info', `Connecting to ${baseUrl}...`);
        }

        const response = await fetch(`${baseUrl}/api/tags`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        if (Array.isArray(data.models)) {
            models = data.models
                .map(describeOllamaModel)
                .filter(Boolean);
        } else {
            models = [];
        }

        if (models.length === 0) {
            throw new Error('No models reported by Ollama.');
        }

        models = prioritizeModelOptions(dedupeModelOptions(models));

        if (!skipEnsurePreferred && baseUrl && !hasModelOption(models, PREFERRED_OLLAMA_MODEL)) {
            const ensured = await ensurePreferredModelAvailable(baseUrl, triggeredByUser);
            if (ensured) {
                return loadOllamaModels(triggeredByUser, true);
            }
        }

        const previewList = models.slice(0, 6).map(model => model.value).join(', ');
        const previewSuffix = models.length > 6 ? ' …' : '';
        setLlmStatus(
            'success',
            `Loaded ${models.length} model${models.length === 1 ? '' : 's'} from Ollama: ${previewList}${previewSuffix}`
        );
    } catch (error) {
        console.warn('Unable to load Ollama models:', error);
        if (triggeredByUser) {
            setLlmStatus('error', `Failed to refresh models: ${error.message}`);
        } else {
            setLlmStatus('warning', 'Could not reach Ollama. Using default model list.');
        }
        models = prioritizeModelOptions(dedupeModelOptions(buildDefaultModelOptions()));
    }

    if (models.length === 0) {
        models = prioritizeModelOptions(dedupeModelOptions(buildDefaultModelOptions()));
    }

    modelSelect.innerHTML = models
        .map(model => `<option value="${model.value}">${model.label}</option>`)
        .join('');

    const preferred = modelSelect.dataset.preferredModel;
    if (preferred) {
        const preferredOption = models.find(model => model.value === preferred || model.label === preferred);
        if (preferredOption) {
            modelSelect.value = preferredOption.value;
        }
    }
    delete modelSelect.dataset.preferredModel;

    if (!modelSelect.value && hasModelOption(models, PREFERRED_OLLAMA_MODEL)) {
        modelSelect.value = PREFERRED_OLLAMA_MODEL;
    }

    if (!modelSelect.value && models.length > 0) {
        modelSelect.value = models[0].value;
    }

    setTimeout(() => updateLlmSendAvailability(), 0);
}

function updateLlmSendAvailability() {
    const sendButton = document.getElementById('llmSendButton');
    const modelSelect = document.getElementById('ollamaModel');
    if (!sendButton || !modelSelect) {
        return;
    }
    const hasModel = Boolean(modelSelect.value);
    sendButton.disabled = !(hasModel && extractedData);
}


async function tryMultipleExtractionMethods(url) {
            let html = '';
            const sanitizedUrl = url.trim();
            const strippedUrl = sanitizedUrl.replace(/^https?:\/\//, '');
            const hasWwwPrefix = strippedUrl.startsWith('www.');
            
            // Method 1: Try CORS proxy (primary method)
            try {
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(sanitizedUrl)}`;
                const response = await fetch(proxyUrl);
                if (response.ok) {
                    html = await response.text();
                    if (html && html.length > 100) { // Reasonable content length
                        return html;
                    }
                }
            } catch (proxyError) {
                console.warn('CORS proxy failed:', proxyError);
            }
            
            // Method 2: Try text-only mirror via r.jina.ai (http)
            try {
                const textiseUrl = `https://r.jina.ai/http://${strippedUrl}`;
                const response = await fetch(textiseUrl);
                if (response.ok) {
                    html = await response.text();
                    if (html && html.length > 100) {
                        return html;
                    }
                }
            } catch (textiseError) {
                console.warn('Textise service failed:', textiseError);
            }
            
            // Method 3: Try with www prefix if missing
            if (!hasWwwPrefix) {
                try {
                    const textiseAltUrl = `https://r.jina.ai/http://www.${strippedUrl}`;
                    const response = await fetch(textiseAltUrl);
                    if (response.ok) {
                        html = await response.text();
                        if (html && html.length > 100) {
                            return html;
                        }
                    }
                } catch (textiseAltError) {
                    console.warn('Alternative textise service failed:', textiseAltError);
                }
            }
            
            // Method 4: Try forcing https upstream
            try {
                const textiseHttpsUrl = `https://r.jina.ai/http://https://${strippedUrl}`;
                const response = await fetch(textiseHttpsUrl);
                if (response.ok) {
                    html = await response.text();
                    if (html && html.length > 100) {
                        return html;
                    }
                }
            } catch (textiseHttpsError) {
                console.warn('HTTPS textise service failed:', textiseHttpsError);
            }
            
            throw new Error('All extraction methods failed. The page may be blocking access or require JavaScript.');
        }

        async function tryTextExtractionServices(url) {
            const sanitizedUrl = url.trim();
            const strippedUrl = sanitizedUrl.replace(/^https?:\/\//, '');
            const services = [
                `https://r.jina.ai/http://${strippedUrl}`,
                `https://r.jina.ai/http://https://${strippedUrl}`
            ];
            
            if (!strippedUrl.startsWith('www.')) {
                services.push(`https://r.jina.ai/http://www.${strippedUrl}`);
            }
            
            for (const serviceUrl of services) {
                try {
                    const response = await fetch(serviceUrl);
                    if (response.ok) {
                        const html = await response.text();
                        if (html && html.length > 100 && !html.includes('JavaScript is disabled')) {
                            return html;
                        }
                    }
                } catch (error) {
                    console.warn(`Service ${serviceUrl} failed:`, error);
                }
            }
            
            return null;
        }

        async function tryWaybackMachine(url) {
            try {
                const waybackUrl = `https://webcache.googleusercontent.com/search?q=cache:${url}`;
                const response = await fetch(waybackUrl);
                if (response.ok) {
                    const html = await response.text();
                    if (html && html.length > 100 && !html.includes('JavaScript is disabled')) {
                        return html;
                    }
                }
            } catch (error) {
                console.warn('Wayback Machine failed:', error);
            }
            
            return null;
        }

        function isJavaScriptRequired(doc) {
            const bodyText = (doc.body?.textContent || '').toLowerCase();
            const titleText = (doc.title || '').toLowerCase();
            
            // Check for common JavaScript-disabled messages
            const jsDisabledPatterns = [
                'javascript is disabled',
                'javascript is required',
                'enable javascript',
                'please enable javascript',
                'this site requires javascript',
                'verification required',
                'not a robot',
                'cloudflare',
                'checking your browser',
                'enable javascript and reload'
            ];
            
            // Check if page contains JavaScript-disabled messages
            for (const pattern of jsDisabledPatterns) {
                if (bodyText.includes(pattern) || titleText.includes(pattern)) {
                    return true;
                }
            }
            
            // Check if page is mostly empty (likely requires JS)
            const textLength = bodyText.length;
            const elementCount = doc.querySelectorAll('*').length;
            
            if (textLength < 50 && elementCount < 10) {
                return true;
            }
            
            // Check for common JS-required indicators
            const jsIndicators = [
                doc.querySelector('[data-require-js]'),
                doc.querySelector('.js-required'),
                doc.querySelector('#noscript'),
                doc.querySelector('meta[name="generator"][content*="javascript"]'),
                doc.querySelector('script[src*="app"]'),
                doc.querySelector('script[src*="bundle"]')
            ];
            
            return jsIndicators.some(indicator => indicator !== null);
        }

        function processExtractedContent(url, doc, extractionMethod = 'direct') {
            // Wait for dynamic content simulation
            const waitTime = parseInt(document.getElementById('waitTime').value);
            setProgress(70, 'Processing content...');
            
            // Simulate waiting for dynamic content
            return new Promise(resolve => {
                setTimeout(() => {
                    setProgress(80, 'Formatting for LLM...');
                    
                    // Extract content
                    const content = {
                        url: url,
                        timestamp: new Date().toISOString(),
                        metadata: extractMetadata(doc),
                        content: extractMainContent(doc),
                        links: extractLinks(doc),
                        images: extractImages(doc),
                        structure: extractStructure(doc),
                        extractionMethod: extractionMethod
                    };
                    
                    resolve(content);
                }, Math.min(waitTime, 2000)); // Cap wait time for alternative methods
            });
        }

        function getPlaywrightEndpoint() {
            const input = document.getElementById('playwrightServer');
            let baseUrl = (input?.value || '').trim();
            if (!baseUrl) {
                baseUrl = 'http://localhost:3050';
            }
            try {
                const normalized = new URL(baseUrl);
                let path = normalized.pathname || '';
                if (path === '/') {
                    path = '';
                } else {
                    path = path.replace(/\/+$/, '');
                }
                return `${normalized.origin}${path}/extract-with-playwright`;
            } catch (error) {
                throw new Error('Invalid Playwright server URL. Please provide a valid address (e.g., http://localhost:3050).');
            }
        }

        async function extractWithPlaywright(url) {
            try {
                setProgress(35, 'Starting Playwright browser...');
                
                const endpoint = getPlaywrightEndpoint();
                
                // Use Playwright to launch real Chrome browser
                const response = await fetch(endpoint, {
                    method: 'POST',
                    mode: 'cors',
                    credentials: 'omit',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        url: url,
                        waitTime: parseInt(document.getElementById('waitTime').value),
                        options: {
                            includeImages: document.getElementById('includeImages').checked,
                            includeLinks: document.getElementById('includeLinks').checked,
                            includeMetadata: document.getElementById('includeMetadata').checked,
                            cleanContent: document.getElementById('cleanContent').checked
                        }
                    })
                });
                
                if (!response.ok) {
                    if ([404, 405].includes(response.status)) {
                        showPlaywrightInstructions(`The Playwright helper server responded with status ${response.status}. Confirm it is running at ${endpoint} and accepts POST requests.`);
                        const statusText = response.status === 405 ? 'Method Not Allowed' : 'Not Found';
                        throw new Error(`Playwright helper server returned ${response.status} (${statusText}).`);
                    }
                    throw new Error(`Playwright server error: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    setProgress(65, 'Browser extraction successful...');
                    return result.html;
                } else {
                    throw new Error(result.error || 'Playwright extraction failed');
                }
                
            } catch (error) {
                // If Playwright server is not available, show instructions
                if (error.message.includes('Failed to fetch') || error.message.includes('Invalid Playwright server URL')) {
                    showPlaywrightInstructions(error.message);
                    throw new Error('Playwright server not reachable. See instructions below to set up browser automation.');
                }
                throw error;
            }
        }

        function showPlaywrightInstructions(detailsMessage) {
            const endpoint = (() => {
                try {
                    return getPlaywrightEndpoint();
                } catch {
                    return 'http://localhost:3050/extract-with-playwright';
                }
            })();
            const baseForInput = endpoint.replace(/\/extract-with-playwright$/, '');

            const serverSnippet = `
const { chromium } = require('playwright');
const express = require('express');
const app = express();

// Allow browser UI fetches from file:// origins
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    if (req.method === 'OPTIONS') {
        return res.sendStatus(200);
    }
    next();
});

app.use(express.json());

app.post('/extract-with-playwright', async (req, res) => {
    try {
        const { url, waitTime } = req.body;
        const effectiveWait = Number.isFinite(waitTime) ? waitTime : 3000;
        const navigationTimeout = Math.max(effectiveWait + 10000, 45000);
        
        const browser = await chromium.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        const context = await browser.newContext({
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        });
        const page = await context.newPage();
        page.setDefaultNavigationTimeout(navigationTimeout);
        
        console.log(\`Navigating to: \${url}\`);
        try {
            await page.goto(url, { waitUntil: 'domcontentloaded', timeout: navigationTimeout });
        } catch (navError) {
            if (navError.name === 'TimeoutError') {
                console.warn('Navigation timed out waiting for DOMContentLoaded:', navError.message);
            } else {
                throw navError;
            }
        }
        
        try {
            await page.waitForLoadState('networkidle', { timeout: Math.min(navigationTimeout, 15000) });
        } catch (idleError) {
            console.warn('Network idle state not reached within timeout, continuing extraction.');
        }
        
        console.log(\`Waiting \${effectiveWait}ms for dynamic content...\`);
        await page.waitForTimeout(effectiveWait);
        
        const html = await page.content();
        await context.close();
        await browser.close();
        
        res.json({ success: true, html });
    } catch (error) {
        console.error('Playwright error:', error);
        res.json({ success: false, error: error.message });
    }
});

const PORT = process.env.PORT || 3050;
app.listen(PORT, () => {
    console.log(\`🚀 Playwright extraction server running on port \${PORT}\`);
    console.log('Ready to extract JavaScript-heavy content!');
});`.trim();

            const instructions = `
                <h3>🚀 Playwright Browser Setup Required</h3>
                <p>To extract content from JavaScript-heavy pages, you need to run a Playwright server:</p>
                
                <h4>Step 1: Install Dependencies</h4>
                <pre><code>npm install playwright express</code></pre>
                
                <h4>Step 2: Create Server File</h4>
                <p>Create a file named <code>extract-server.js</code>:</p>
                <pre><code>${serverSnippet}</code></pre>
                
                <h4>Step 3: Start Server</h4>
                <pre><code>node extract-server.js
# starts on port 3050 by default.
# choose a custom port if needed:
PORT=4000 node extract-server.js</code></pre>

                <h4>Step 3 (Docker alternative)</h4>
                <p>Or build a container image and run it:</p>
                <pre><code>docker build -t playwright-extractor -f docker/Dockerfile .</code></pre>
                <pre><code>docker run --rm -p 3050:3050 playwright-extractor</code></pre>
                
                <h4>Step 4 (Docker Compose for UI + server)</h4>
                <p>To run both the Playwright helper and this UI together:</p>
                <pre><code>docker compose -f docker/docker-compose.yml up --build -d</code></pre>
                <p>The UI will be served at <code>http://localhost:8080</code> and will reach the helper at <code>http://playwright-extractor:3050</code> inside the Docker network.</p>
                
                <h4>Step 5: Try Again</h4>
                <p>Once the server is running, update the "Playwright Server URL" field if needed (current value: <code>${baseForInput}</code>) and try extracting again.</p>
                
                <p><strong>Note:</strong> The first time you run this, Playwright will download Chromium browsers automatically.</p>
            `;
            
            const warningElement = document.getElementById('warningMessage');
            warningElement.innerHTML = instructions;
            warningElement.style.display = 'block';
            warningElement.style.maxHeight = '400px';
            warningElement.style.overflow = 'auto';

            if (detailsMessage) {
                warningElement.innerHTML = `<p>${detailsMessage}</p>` + warningElement.innerHTML;
            }
        }

        function extractMetadata(doc) {
            if (!document.getElementById('includeMetadata').checked) {
                return {};
            }

            const metadata = {
                title: doc.title || 'No title',
                description: getMetaContent(doc, 'description'),
                keywords: getMetaContent(doc, 'keywords'),
                author: getMetaContent(doc, 'author'),
                canonical: getCanonicalUrl(doc),
                language: doc.documentElement.lang || 'unknown',
                viewport: getMetaContent(doc, 'viewport')
            };

            // Open Graph data
            const ogData = {};
            ['title', 'description', 'image', 'url', 'type', 'site_name'].forEach(prop => {
                const content = getMetaContent(doc, `og:${prop}`, 'property');
                if (content) ogData[prop] = content;
            });

            if (Object.keys(ogData).length > 0) {
                metadata.openGraph = ogData;
            }

            return metadata;
        }

        function extractMainContent(doc) {
            try {
                const options = {
                    includeImages: document.getElementById('includeImages').checked,
                    includeLinks: document.getElementById('includeLinks').checked,
                    cleanContent: document.getElementById('cleanContent').checked
                };

                let content = '';
                
                // Try to find main content area
                const mainSelectors = [
                    'main', 'article', '[role="main"]', 
                    '.content', '.main-content', '#content',
                    '.post-content', '.entry-content'
                ];
                
                let mainElement = null;
                for (const selector of mainSelectors) {
                    mainElement = doc.querySelector(selector);
                    if (mainElement) break;
                }
                
                // Fallback to body if no main content found
                if (!mainElement) {
                    mainElement = doc.body;
                }

                // Remove unwanted elements
                const unwantedSelectors = [
                    'script', 'style', 'nav', 'header', 'footer', 
                    '.sidebar', '.menu', '.navigation', '.ads',
                    '.advertisement', '.social-share'
                ];
                
                const clone = mainElement.cloneNode(true);
                unwantedSelectors.forEach(selector => {
                    const elements = clone.querySelectorAll(selector);
                    elements.forEach(el => el.remove());
                });

                // Extract text content
                if (options.cleanContent) {
                    content = cleanTextContent(clone);
                } else {
                    content = clone.textContent || clone.innerText || '';
                }

                // Add image alt text if requested
                if (options.includeImages) {
                    const images = clone.querySelectorAll('img');
                    if (images && images.length > 0) {
                        const imageTexts = Array.from(images)
                            .map(img => img.alt || img.title || '[Image]')
                            .filter(text => text && text !== '[Image]');
                        
                        if (imageTexts && imageTexts.length > 0) {
                            content += '\n\nIMAGES:\n' + imageTexts.join('\n');
                        }
                    }
                }

                // Add link text if requested
                if (options.includeLinks) {
                    const links = clone.querySelectorAll('a[href]');
                    if (links && links.length > 0) {
                        const linkTexts = Array.from(links)
                            .map(link => (link.textContent || '').trim())
                            .filter(text => text.length > 0);
                        
                        if (linkTexts && linkTexts.length > 0) {
                            content += '\n\nLINKS:\n' + linkTexts.join('\n');
                        }
                    }
                }

                return content.trim();
            } catch (error) {
                console.warn('Error extracting main content:', error);
                return doc.body ? (doc.body.textContent || doc.body.innerText || '').trim() : '';
            }
        }

        function extractLinks(doc) {
            try {
                const links = Array.from(doc.querySelectorAll('a[href]'))
                    .map(link => ({
                        text: (link.textContent || '').trim(),
                        href: link.href || '',
                        title: link.title || ''
                    }))
                    .filter(link => link && link.text && link.text.length > 0);
                
                return links || [];
            } catch (error) {
                console.warn('Error extracting links:', error);
                return [];
            }
        }

        function extractImages(doc) {
            const images = Array.from(doc.querySelectorAll('img'))
                .map(img => ({
                    src: img.src,
                    alt: img.alt || '',
                    title: img.title || '',
                    width: img.width || 'unknown',
                    height: img.height || 'unknown'
                }))
                .filter(img => img && img.src);
            
            return images || [];
        }

        function extractStructure(doc) {
            try {
                const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6'))
                    .map(heading => ({
                        level: parseInt(heading.tagName.charAt(1)),
                        text: (heading.textContent || '').trim(),
                        id: heading.id || ''
                    }));

                const lists = Array.from(doc.querySelectorAll('ul, ol'))
                    .map(list => ({
                        type: list.tagName.toLowerCase(),
                        items: Array.from(list.querySelectorAll('li')).map(li => (li.textContent || '').trim())
                    }));

                return {
                    headings: headings || [],
                    lists: lists || [],
                    wordCount: (doc.body.textContent || '').split(/\s+/).length,
                    elementCount: doc.querySelectorAll('*').length || 0
                };
            } catch (error) {
                console.warn('Error extracting structure:', error);
                return {
                    headings: [],
                    lists: [],
                    wordCount: 0,
                    elementCount: 0
                };
            }
        }

        function cleanTextContent(element) {
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let text = '';
            let node;
            while (node = walker.nextNode()) {
                const parent = node.parentElement;
                if (parent && !['script', 'style'].includes(parent.tagName.toLowerCase())) {
                    text += node.textContent + ' ';
                }
            }

            return text
                .replace(/\s+/g, ' ')
                .replace(/\n\s*\n/g, '\n\n')
                .trim();
        }

        function getMetaContent(doc, name, attribute = 'name') {
            const meta = doc.querySelector(`meta[${attribute}="${name}"]`);
            return meta ? meta.content : '';
        }

        function getCanonicalUrl(doc) {
            const canonical = doc.querySelector('link[rel="canonical"]');
            return canonical ? canonical.href : '';
        }

        function formatForLLM(data) {
            let formatted = `# Web Page Content Analysis\n\n`;
            formatted += `**URL:** ${data.url}\n`;
            formatted += `**Extracted:** ${data.timestamp}\n`;
            formatted += `**Method:** ${data.extractionMethod || 'direct'}\n\n`;
            
            if (data.metadata && Object.keys(data.metadata).length > 0) {
                formatted += `## Metadata\n\n`;
                Object.entries(data.metadata).forEach(([key, value]) => {
                    if (typeof value === 'object') {
                        formatted += `**${key}:**\n`;
                        Object.entries(value).forEach(([subKey, subValue]) => {
                            formatted += `  - ${subKey}: ${subValue}\n`;
                        });
                    } else {
                        formatted += `**${key}:** ${value}\n`;
                    }
                });
                formatted += '\n';
            }

            formatted += `## Main Content\n\n${data.content}\n\n`;

            if (data.structure) {
                formatted += `## Structure Analysis\n\n`;
                formatted += `- **Word Count:** ${data.structure.wordCount}\n`;
                formatted += `- **Element Count:** ${data.structure.elementCount}\n`;
                
                if (data.structure.headings.length > 0) {
                    formatted += `\n### Headings\n\n`;
                    data.structure.headings.forEach(heading => {
                        const indent = '  '.repeat(heading.level - 1);
                        formatted += `${indent}- ${heading.text}\n`;
                    });
                }
            }

            if (data.links && data.links.length > 0) {
                formatted += `\n## Links (${data.links.length})\n\n`;
                data.links.slice(0, 20).forEach((link, i) => {
                    formatted += `${i + 1}. ${link.text} - ${link.href}\n`;
                });
                if (data.links.length > 20) {
                    formatted += `... and ${data.links.length - 20} more links\n`;
                }
            }

            if (data.images && data.images.length > 0) {
                formatted += `\n## Images (${data.images.length})\n\n`;
                data.images.slice(0, 10).forEach((img, i) => {
                    formatted += `${i + 1}. ${img.alt || 'No alt text'} - ${img.src}\n`;
                });
                if (data.images.length > 10) {
                    formatted += `... and ${data.images.length - 10} more images\n`;
                }
            }

            // Add extraction notes
            if (data.extractionMethod) {
                formatted += `\n## Extraction Notes\n\n`;
                switch (data.extractionMethod) {
                    case 'playwright':
                        formatted += `Content rendered with a Playwright-controlled browser to execute JavaScript before extraction.\n`;
                        break;
                    case 'playwright-fallback':
                        formatted += `Playwright rendering was attempted but unavailable. Fallback text-only services were used; dynamic content may be missing.\n`;
                        break;
                    case 'cached':
                        formatted += `Content retrieved from a cached copy (Google Webcache/Wayback). It may differ from the live page.\n`;
                        break;
                    case 'alternative':
                        formatted += `This page requires JavaScript to load properly. Content was extracted using alternative methods.\n`;
                        formatted += `Some dynamic content may be missing. For complete content, consider:\n`;
                        formatted += `- Enabling JavaScript in your browser\n`;
                        formatted += `- Using a browser automation tool\n`;
                        formatted += `- Accessing the page directly\n`;
                        break;
                    default:
                        formatted += `Extraction method: ${data.extractionMethod}.\n`;
                }
            }

            return formatted;
        }

        function convertToMarkdown(data) {
            let markdown = `# ${data.metadata.title || 'Untitled Page'}\n\n`;
            
            if (data.metadata.description) {
                markdown += `> ${data.metadata.description}\n\n`;
            }

            markdown += `**URL:** ${data.url}\n\n`;
            markdown += `---\n\n`;

            // Convert content to basic markdown
            const content = data.content
                .replace(/\n\n+/g, '\n\n')
                .replace(/^([A-Z][^.!?]*[.!?])$/gm, '$1\n\n');
            
            markdown += content;

            return markdown;
        }

function getExtractionDataByIndex(index) {
    if (typeof index === 'number' && index >= 0 && index < extractionHistory.length) {
        return extractionHistory[index];
    }
    return extractedData;
}

async function copyLlmResponse(container) {
    const contentEl = container?.querySelector('.assistant-llm');
    if (!contentEl) {
        showWarning('Nothing to copy from the LLM response.');
        return;
    }

    const text = contentEl.innerText.trim();
    if (!text) {
        showWarning('LLM response is empty, nothing to copy.');
        return;
    }

    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
        } else {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
        showSuccess('LLM response copied to clipboard!');
    } catch (error) {
        console.error('Failed to copy LLM response:', error);
        showError('Could not copy the LLM response. Please copy it manually.');
    }
}

async function copyUserMessage(container) {
    const contentEl = container?.querySelector('pre');
    if (!contentEl) {
        showWarning('Nothing to copy from the instruction.');
        return;
    }

    const text = contentEl.innerText.trim();
    if (!text) {
        showWarning('Instruction is empty, nothing to copy.');
        return;
    }

    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
        } else {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
        showSuccess('Instruction copied to clipboard!');
    } catch (error) {
        console.error('Failed to copy instruction:', error);
        showError('Could not copy the instruction. Please copy it manually.');
    }
}

async function copyExtractionContent(format, extractionIndex) {
    const data = getExtractionDataByIndex(extractionIndex);
    if (!data) {
        showError('No content to copy');
                return;
            }

            let content = '';
            let label = '';

            switch (format) {
                case 'main': {
                    const mainContent = data.content || '';
                    if (!mainContent.trim()) {
                        showWarning('Main content is empty, nothing to copy.');
                        return;
                    }
                    content = mainContent;
                    label = 'Main content';
                    break;
                }
                case 'txt':
                    content = formatForLLM(data);
                    label = 'Text';
                    break;
                case 'md':
                    content = convertToMarkdown(data);
                    label = 'Markdown';
                    break;
                case 'json':
                    content = JSON.stringify(data, null, 2);
                    label = 'JSON';
                    break;
                case 'html':
                    content = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${data.metadata?.title || 'Extracted Content'}</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>${data.metadata?.title || 'Extracted Content'}</h1>
    <pre>${formatForLLM(data)}</pre>
</body>
</html>`;
                    label = 'HTML';
                    break;
                default:
                    showError('Unsupported copy format requested.');
                    return;
            }

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(content);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = content;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.focus();
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }
                showSuccess(`${label} copied to clipboard!`);
            } catch (error) {
                console.error('Clipboard copy failed:', error);
                showError(`Failed to copy ${label.toLowerCase()} content. Please copy manually.`);
            }
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        function showProgress() {
            document.getElementById('progressSection').style.display = 'block';
        }

        function hideProgress() {
            document.getElementById('progressSection').style.display = 'none';
        }

        function setProgress(percent, status) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('statusText').textContent = status;
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = `❌ ${message}`;
            errorElement.style.display = 'block';
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 5000);
        }

        function showSuccess(message) {
            const successElement = document.getElementById('successMessage');
            successElement.textContent = `✅ ${message}`;
            successElement.style.display = 'block';
            setTimeout(() => {
                successElement.style.display = 'none';
            }, 3000);
        }

        function showWarning(message) {
            const warningElement = document.getElementById('warningMessage');
            warningElement.innerHTML = `⚠️ ${message}`;
            warningElement.style.display = 'block';
            setTimeout(() => {
                warningElement.style.display = 'none';
            }, 8000);
        }

        function hideMessages() {
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
            document.getElementById('warningMessage').style.display = 'none';
            document.getElementById('extractionMethod').style.display = 'none';
        }
    </script>
</body>
</html>
